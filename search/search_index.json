{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Rubik ORM","text":"<p>Rubik is a strict, type-safe, and driver-agnostic Object-Relational Mapper (ORM) for PHP 8.1+. It implements the Active Record pattern but distinctively separates schema definition (<code>SchemaTrait</code>), query construction (<code>Query</code>), and persistence (<code>CrudTrait</code>).</p>"},{"location":"#architectural-philosophy","title":"Architectural Philosophy","text":"<p>Rubik was built to solve specific problems found in heavier ORMs:</p> <ol> <li>Code-First Truth: The database schema is defined inside the Model via the <code>fields()</code> method. There are no separate migration files that can drift out of sync with your classes.</li> <li>Strict Validation: The schema builder (<code>Column</code> class) validates types, lengths, and defaults before generating SQL.</li> <li>Driver Abstraction: You define a column as <code>Column::Boolean()</code>. Rubik decides if that becomes <code>TINYINT(1)</code> (MySQL) or <code>INTEGER</code> (SQLite) at runtime.</li> <li>Zero-Dependency: It relies solely on <code>ext-pdo</code>.</li> </ol>"},{"location":"#the-core-components","title":"The Core Components","text":"Component Responsibility <code>Rubik</code> The singleton connection manager. Handles <code>PDO</code> instantiation and transaction state. <code>Model</code> The entry point. Uses traits to compose capabilities (CRUD, Schema, Querying). <code>Query</code> A fluent SQL builder. Handles sanitization, parameter binding, and hydration. <code>Column</code> A meta-programming factory. Validates and normalizes field definitions. <code>Relation</code> Abstract logic for connecting models (HasOne, BelongsTo, etc.)."},{"location":"#requirement-checklist","title":"Requirement Checklist","text":"<ul> <li>PHP: 8.1 or higher.</li> <li>Extensions: <code>ext-pdo</code>, plus <code>ext-pdo_sqlite</code> or <code>ext-pdo_mysql</code>.</li> <li>Database:</li> <li>MySQL 5.7+ or MariaDB 10.2+</li> <li>SQLite 3.25+ (Required for proper Foreign Key support)</li> </ul>"},{"location":"#basic-usage-teaser","title":"Basic Usage Teaser","text":"<pre><code>use App\\Models\\User;\n\n// 1. Definition\nclass User extends Model {\n    protected static function fields(): array {\n        return [\n            'id'   =&gt; Column::Integer(primaryKey: true, autoIncrement: true),\n            'name' =&gt; Column::Varchar(length: 100, notNull: true)\n        ];\n    }\n}\n\n// 2. Synchronization\nUser::createTable(ifNotExists: true);\n\n// 3. Interaction\n$user = new User();\n$user-&gt;name = \"Ada\u00edas\";\n$user-&gt;save();\n</code></pre>"},{"location":"advanced/","title":"Advanced Topics","text":""},{"location":"advanced/#transactions","title":"Transactions","text":"<p>Rubik wraps PDO transactions. You must ensure your tables support transactions (e.g., InnoDB for MySQL).</p>"},{"location":"advanced/#helper-method-recommended","title":"Helper Method (Recommended)","text":"<p>The <code>transaction</code> method automatically commits on success and rolls back if any <code>Throwable</code> is caught.</p> <pre><code>try {\n    Rubik::transaction(function() {\n        $u = new User();\n        $u-&gt;save();\n\n        if (somethingWrong()) {\n            throw new Exception(\"Rollback!\");\n        }\n    });\n} catch (Exception $e) {\n    // Transaction already rolled back here\n}\n</code></pre>"},{"location":"advanced/#manual-control","title":"Manual Control","text":"<pre><code>Rubik::beginTransaction();\n// ... logic\nRubik::commit();\n// or\nRubik::rollBack();\n</code></pre>"},{"location":"advanced/#security-the-sql-value-object","title":"Security: The <code>SQL</code> Value Object","text":"<p>Rubik automatically escapes all inputs passed to <code>where</code>, <code>insert</code>, and <code>update</code>. However, sometimes you need to pass raw SQL (e.g., database functions).</p> <p>To do this securely, use the <code>AdaiasMagdiel\\Rubik\\SQL</code> class. Rubik detects instances of this class and injects the string verbatim.</p> <pre><code>use AdaiasMagdiel\\Rubik\\SQL;\n\n// BAD: Potentially unsafe if $input is dirty\n$q-&gt;update(['updated_at' =&gt; \"NOW()\"]); // Will define string \"NOW()\"\n\n// GOOD:\n$q-&gt;update(['updated_at' =&gt; SQL::raw('NOW()')]); // Will execute SQL function\n</code></pre> <p>Security Warning</p> <p>NEVER pass user-supplied data into <code>SQL::raw()</code>.</p> <pre><code>Bad: `SQL::raw(\"dATEDIFF(now(), '$userInput')\")` -&gt; **SQL Injection**.\nGood: `where('date', '&lt;', $userInput)` -&gt; **Safe (Parameterized)**.\n</code></pre>"},{"location":"advanced/#identifiers-vs-values","title":"Identifiers vs Values","text":"<p>Rubik internally distinguishes between:</p> <ol> <li>Identifiers: Table names and Column names. These are sanitized via <code>quoteIdentifier</code> (adds backticks <code>`</code> or double quotes <code>\"</code>).</li> <li>Values: Data content. These are parameterized as <code>:placeholder</code>.</li> </ol>"},{"location":"advanced/#scopes-magic-methods","title":"Scopes (Magic Methods)","text":"<p>You can define reusable query logic in your Model using the <code>scope</code> prefix.</p> <p>Definition:</p> <pre><code>class User extends Model {\n    public function scopeActive(Query $query) {\n        $query-&gt;where('status', 'active');\n    }\n}\n</code></pre> <p>Usage:</p> <pre><code>// Call it without the 'scope' prefix\n$users = User::active()-&gt;orderBy('id')-&gt;all();\n</code></pre>"},{"location":"advanced/#handling-database-differences","title":"Handling Database Differences","text":"<p>Rubik attempts to abstract differences, but some leak through:</p> <ol> <li>Auto-Increment: SQLite handles standard <code>INTEGER PRIMARY KEY</code> as auto-increment. MySQL requires the explicit <code>AUTO_INCREMENT</code> flag. Rubik's <code>SchemaTrait</code> handles this generation logic.</li> <li>String vs Text: In SQLite, <code>VARCHAR</code> is mapped to <code>TEXT</code>. In MySQL, strict lengths are enforced.</li> <li>JSON: MySQL has a native <code>JSON</code> type. SQLite stores it as <code>TEXT</code>. Rubik validates JSON validity in PHP before saving to ensure consistency.</li> </ol>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>Rubik is installed via Composer.</p> <pre><code>composer require adaiasmagdiel/rubik\n</code></pre>"},{"location":"getting-started/#connection-management","title":"Connection Management","text":"<p>Rubik uses a Singleton pattern for database connections. This means your application currently supports one active database connection at a time.</p>"},{"location":"getting-started/#the-rubikconnect-method","title":"The <code>Rubik::connect</code> Method","text":"<p>You must call <code>connect</code> before your application attempts any database operations.</p> <pre><code>public static function connect(\n    Driver $driver,\n    string $username = '',\n    string $password = '',\n    string $database = '',\n    int $port = 3306,\n    string $host = 'localhost',\n    string $charset = 'utf8mb4',\n    string $path = \":memory:\",\n    array $options = []\n): void\n</code></pre>"},{"location":"getting-started/#driver-sqlite","title":"Driver: SQLite","text":"<p>For SQLite, the <code>path</code> argument is critical. Rubik automatically executes <code>PRAGMA foreign_keys = ON;</code> for SQLite connections to ensure referential integrity.</p> <pre><code>use AdaiasMagdiel\\Rubik\\Rubik;\nuse AdaiasMagdiel\\Rubik\\Enum\\Driver;\n\nRubik::connect(\n    driver: Driver::SQLITE,\n    path: __DIR__ . '/database.sqlite', // or \":memory:\"\n    options: [\n        PDO::ATTR_TIMEOUT =&gt; 5 // Optional PDO settings\n    ]\n);\n</code></pre>"},{"location":"getting-started/#driver-mysql-mariadb","title":"Driver: MySQL / MariaDB","text":"<p>Rubik handles connection strings automatically.</p> <pre><code>use AdaiasMagdiel\\Rubik\\Rubik;\nuse AdaiasMagdiel\\Rubik\\Enum\\Driver;\n\nRubik::connect(\n    driver: Driver::MYSQL,\n    host: '127.0.0.1',\n    port: 3306,\n    database: 'production_db',\n    username: 'admin',\n    password: 'secure_password',\n    charset: 'utf8mb4'\n);\n</code></pre> <p>Strict Mode</p> <p>Rubik sets <code>PDO::ATTR_ERRMODE</code> to <code>PDO::ERRMODE_EXCEPTION</code> by default. Any SQL error will throw a <code>PDOException</code>. It also sets <code>ATTR_EMULATE_PREPARES</code> to <code>false</code> for security.</p>"},{"location":"getting-started/#disconnecting","title":"Disconnecting","text":"<p>If you need to close the connection or switch databases during testing:</p> <pre><code>Rubik::disconnect();\n</code></pre>"},{"location":"getting-started/#global-state-helper","title":"Global State Helper","text":"<p>You can check if a connection is active or access the raw PDO instance if you need to perform operations outside the ORM.</p> <pre><code>if (Rubik::isConnected()) {\n    $pdo = Rubik::getConn();\n    // Do raw PDO stuff...\n}\n</code></pre>"},{"location":"internals/","title":"Architecture &amp; Deep Reflection","text":"<p>This section provides a deep dive into the design decisions, trade-offs, and internal mechanics of the Rubik ORM.</p>"},{"location":"internals/#1-the-schema-definition-strategy-column-meta-programming","title":"1. The Schema Definition Strategy (<code>Column</code> Meta-programming)","text":"<p>Rubik employs a Code-First approach where the schema is the source of truth for validations.</p>"},{"location":"internals/#the-mechanism","title":"The Mechanism","text":"<p>The <code>Column</code> class utilizes the <code>__callStatic</code> magic method combined with a constant <code>TYPE_META</code> array. This allows for:</p> <ol> <li>Driver Abstraction: A <code>Column::Boolean()</code> is automatically translated to <code>INTEGER</code> for SQLite and <code>TINYINT(1)</code> for MySQL at runtime.</li> <li>Input Validation: Before the schema reaches the database, arguments (like <code>length</code>, <code>precision</code>) are validated via static validators (e.g., <code>validateDecimal</code>).</li> <li>Fluency: It avoids verbose class instantiations (e.g., <code>new Column('varchar', ...)</code>), preferring <code>Column::Varchar(...)</code>.</li> </ol>"},{"location":"internals/#reflection","title":"Reflection","text":"<p>This design centralizes cross-database compatibility logic. Instead of having separate <code>MySqlBuilder</code> and <code>SqliteBuilder</code> classes for schema creation, the <code>SchemaTrait</code> acts as a unified translator based on the current <code>Driver</code> enum.</p>"},{"location":"internals/#2-singleton-connection-pattern","title":"2. Singleton Connection Pattern","text":"<p>The <code>Rubik</code> class acts as a global singleton manager for the <code>PDO</code> instance.</p> <pre><code>private static ?PDO $pdo = null;\n</code></pre> <p>Trade-off Analysis:</p> <ul> <li>Pro: Extremely simple API. <code>Rubik::connect()</code> allows models to access the database anywhere without dependency injection containers.</li> <li>Con: It creates global state. This makes testing slightly harder (requires explicit teardown) and prevents connecting to multiple databases simultaneously within the same request lifecycle (Multi-tenancy via multiple DBs is not natively supported).</li> </ul>"},{"location":"internals/#3-the-query-builder-sanitization","title":"3. The Query Builder &amp; Sanitization","text":"<p>The <code>Query</code> class is responsible for building SQL. It maintains internal state (<code>$select</code>, <code>$where</code>, <code>$bindings</code>) and compiles them into a string only upon execution.</p>"},{"location":"internals/#security-model","title":"Security Model","text":"<p>Rubik strictly separates Identifiers from Values.</p> <ul> <li>Identifiers (Table/Column names) are sanitized via <code>Rubik::quoteIdentifier()</code>. This handles wrapping names in backticks (MySQL) or double quotes (SQLite).</li> <li>Values are never injected directly into the SQL string unless wrapped in an <code>SQL</code> Value Object. They are passed as PDO parameters.</li> </ul> <p>This dual-layer approach effectively mitigates SQL Injection risks while allowing flexibility via <code>SQL::raw()</code>.</p>"},{"location":"internals/#4-active-record-traits-composition","title":"4. Active Record &amp; Traits Composition","text":"<p>The <code>Model</code> class is abstract and relatively empty. It derives its power almost entirely from Traits:</p> <ul> <li><code>CrudTrait</code>: Persistence logic.</li> <li><code>SchemaTrait</code>: DDL generation.</li> <li><code>QueryTrait</code>: Static proxies.</li> </ul> <p>Reflective Benefit: This composition over inheritance allows the core <code>Model</code> class to remain readable. It physically separates the concern of defining data (<code>SchemaTrait</code>) from saving data (<code>CrudTrait</code>).</p>"},{"location":"internals/#5-relationship-resolution","title":"5. Relationship Resolution","text":"<p>The <code>Relation</code> abstract class and its children (<code>HasMany</code>, etc.) act as specialized Query Builders.</p> <p>When <code>with('posts')</code> is called:</p> <ol> <li>Hydration: The main query fetches parent models.</li> <li>Collection: Keys (e.g., User IDs) are collected from the parents.</li> <li>Batch Query: The relationship executes <code>WHERE user_id IN (...)</code>.</li> <li>Dictionary Matching: Results are mapped back to parents in memory.</li> </ol> <p>Rubik manually handles this matching in <code>Query::eagerLoadRelations</code>, keeping the logic framework-agnostic.</p>"},{"location":"models-lifecycle/","title":"Models &amp; Lifecycle","text":"<p>Rubik Models are the heart of your application. They handle data transport, persistence, and business logic events.</p>"},{"location":"models-lifecycle/#dirty-state-tracking","title":"Dirty State Tracking","text":"<p>Rubik employs an intelligent \"Dirty Checking\" mechanism.</p> <ol> <li>When a model is fetched (<code>find</code>, <code>all</code>), it is considered \"clean\".</li> <li>When you modify a property (<code>$user-&gt;name = 'New'</code>), the model marks that specific field as dirty in <code>$_dirty</code>.</li> <li>When <code>save()</code> or <code>update()</code> is called, only the dirty fields are included in the <code>UPDATE</code> SQL statement.</li> </ol> <p>Benefit: This prevents overwriting data changed by other processes and reduces query size.</p>"},{"location":"models-lifecycle/#the-save-method","title":"The <code>save()</code> Method","text":"<p>The <code>save()</code> method is smart. It determines whether to <code>INSERT</code> or <code>UPDATE</code> based on the internal <code>$exists</code> boolean property.</p> <pre><code>$user = new User();\n$user-&gt;save(); // Performs INSERT, sets $exists = true\n\n$user-&gt;name = \"Changed\";\n$user-&gt;save(); // Performs UPDATE on ID\n</code></pre>"},{"location":"models-lifecycle/#ignore-mode","title":"Ignore Mode","text":"<p>You can pass <code>true</code> to <code>save()</code> to perform an \"Insert Ignore\".</p> <ul> <li>MySQL: <code>INSERT IGNORE INTO...</code></li> <li>SQLite: <code>INSERT OR IGNORE INTO...</code></li> </ul> <pre><code>$user-&gt;save(ignore: true); // Skips error if Duplicate Key occurs\n</code></pre>"},{"location":"models-lifecycle/#batch-operations","title":"Batch Operations","text":""},{"location":"models-lifecycle/#insertmany","title":"<code>insertMany</code>","text":"<p>Inserts multiple arrays of raw data. This bypasses Model events and setters for performance.</p> <pre><code>User::insertMany([\n    ['name' =&gt; 'A', 'email' =&gt; 'a@a.com'],\n    ['name' =&gt; 'B', 'email' =&gt; 'b@b.com'],\n]);\n</code></pre> <p>ID Retrieval</p> <p><code>insertMany</code> attempts to return the inserted IDs. However, due to limitations in SQLite and MySQL &lt; 8.0.22, batch inserts do not reliably return all generated Auto-Increment IDs.</p>"},{"location":"models-lifecycle/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<p>Rubik fires protected methods during the model's lifecycle. Override these in your model to add logic (e.g., Hashing passwords, UUID generation).</p> Hook Trigger Point <code>beforeCreate</code> Before an INSERT query. <code>afterCreate</code> After a successful INSERT. <code>beforeUpdate</code> Before an UPDATE query. <code>afterUpdate</code> After a successful UPDATE. <code>beforeSave</code> Runs before both Create and Update. <code>afterSave</code> Runs after both Create and Update. <code>beforeDelete</code> Before DELETE query. <code>afterDelete</code> After a successful DELETE. <p>Example: Auto-hashing Password</p> <pre><code>class User extends Model {\n    protected function beforeSave(): void {\n        if (isset($this-&gt;_dirty['password'])) {\n            $this-&gt;password = password_hash($this-&gt;password, PASSWORD_BCRYPT);\n        }\n    }\n}\n</code></pre>"},{"location":"models-lifecycle/#serialization","title":"Serialization","text":"<p>Models implement <code>JsonSerializable</code>. When you <code>json_encode($model)</code>, it automatically calls <code>toArray()</code>, which returns the internal <code>$_data</code> array.</p> <pre><code>echo json_encode($user);\n// {\"id\": 1, \"name\": \"John\", ...}\n</code></pre>"},{"location":"models/","title":"Models &amp; Schema","text":"<p>Rubik models represent database tables. They encapsulate logic for data access, validation (via schema), and business rules.</p>"},{"location":"models/#defining-a-model","title":"Defining a Model","text":"<p>To create a model, extend the <code>AdaiasMagdiel\\Rubik\\Model</code> class. You must implement the <code>fields()</code> method to define the table schema.</p> <pre><code>&lt;?php\nnamespace App\\Model;\n\nuse AdaiasMagdiel\\Rubik\\Model;\nuse AdaiasMagdiel\\Rubik\\Column;\nuse AdaiasMagdiel\\Rubik\\SQL;\n\nclass User extends Model\n{\n    // Optional: Explicitly define table name\n    protected static string $table = 'users';\n\n    protected static function fields(): array\n    {\n        return [\n            'id' =&gt; Column::Integer(primaryKey: true, autoIncrement: true),\n\n            'username' =&gt; Column::Varchar(length: 50, unique: true, notNull: true),\n\n            'email' =&gt; Column::Varchar(length: 100, unique: true),\n\n            'is_active' =&gt; Column::Boolean(default: true),\n\n            'created_at' =&gt; Column::DateTime(\n                default: SQL::raw('CURRENT_TIMESTAMP')\n            ),\n\n            // Defining a relationship column\n            'role_id' =&gt; Column::Integer(\n                foreignKey: Column::ForeignKey('id', 'roles', onDelete: 'CASCADE')\n            )\n        ];\n    }\n}\n</code></pre>"},{"location":"models/#schema-management","title":"Schema Management","text":"<p>Rubik allows you to create or drop tables based on the model definition. This is useful for migrations or prototyping.</p> <pre><code>// Create the table if it doesn't exist\nUser::createTable(ifNotExists: true);\n\n// Drop the table\nUser::dropTable(ifExists: true);\n\n// Truncate (empty) the table\nUser::truncateTable();\n</code></pre>"},{"location":"models/#crud-operations","title":"CRUD Operations","text":""},{"location":"models/#creating","title":"Creating","text":"<pre><code>$user = new User();\n$user-&gt;username = \"rubik_dev\";\n$user-&gt;email = \"dev@example.com\";\n$user-&gt;save(); // Returns bool\n</code></pre>"},{"location":"models/#reading","title":"Reading","text":"<pre><code>// Find by Primary Key\n$user = User::find(1);\n\n// Get first matching record\n$user = User::where('username', 'rubik_dev')-&gt;first();\n\n// Get all records\n$users = User::all();\n\n// Pagination\n$page = User::paginate(page: 1, perPage: 15);\n// returns ['data' =&gt; [...], 'total' =&gt; 100, ...]\n</code></pre>"},{"location":"models/#updating","title":"Updating","text":"<p>Only fields that have changed (\"dirty\" fields) are sent to the database.</p> <pre><code>$user = User::find(1);\n$user-&gt;email = \"new_email@example.com\";\n$user-&gt;save();\n</code></pre>"},{"location":"models/#deleting","title":"Deleting","text":"<pre><code>$user = User::find(1);\n$user-&gt;delete();\n</code></pre>"},{"location":"query-builder/","title":"Query Builder","text":"<p>The <code>Query</code> class allows you to construct complex SQL queries using a fluent, chainable interface. It handles all parameter binding automatically to prevent SQL Injection.</p>"},{"location":"query-builder/#retrieving-data","title":"Retrieving Data","text":""},{"location":"query-builder/#all-vs-get","title":"<code>all()</code> vs <code>get()</code>","text":"<ul> <li><code>all()</code>: Executes the query and returns an array of hydrated Model objects (or <code>stdClass</code> if no model is set).</li> <li><code>get()</code>: Alias for <code>all()</code>, commonly used in Relationships.</li> </ul>"},{"location":"query-builder/#first","title":"<code>first()</code>","text":"<p>Adds <code>LIMIT 1</code> and returns a single Model instance or <code>null</code>.</p>"},{"location":"query-builder/#cursor-memory-efficient","title":"<code>cursor()</code> (Memory Efficient)","text":"<p>Uses a PHP Generator to yield one model at a time. Essential for processing thousands of records without running out of RAM.</p> <pre><code>foreach (User::query()-&gt;cursor() as $user) {\n    // Only one User object exists in memory at a time\n    process($user);\n}\n</code></pre>"},{"location":"query-builder/#chunkint-size-callable-cb","title":"<code>chunk(int $size, callable $cb)</code>","text":"<p>Retrieves records in \"pages\" of size <code>$size</code>.</p> <pre><code>User::chunk(100, function(array $users) {\n    // Process 100 users at a time\n});\n</code></pre>"},{"location":"query-builder/#logic-clauses","title":"Logic Clauses","text":""},{"location":"query-builder/#where-orwhere","title":"Where / OrWhere","text":"<ul> <li>Signature: <code>where(col, value)</code> OR <code>where(col, operator, value)</code></li> <li>Signature: <code>where(col, 'IS', null)</code> OR <code>where(col, 'IS NOT', null)</code></li> </ul> <pre><code>$q-&gt;where('votes', '&gt;', 100)\n  -&gt;where('status', 'active') // Implies '='\n  -&gt;orWhere('is_vip', true);\n</code></pre>"},{"location":"query-builder/#wherein","title":"WhereIn","text":"<pre><code>$q-&gt;whereIn('id', [1, 5, 7]);\n</code></pre>"},{"location":"query-builder/#whereexists-subqueries","title":"WhereExists (Subqueries)","text":"<p>Rubik supports subqueries for existence checks.</p> <pre><code>$orders = Order::query()-&gt;where('total', '&gt;', 500);\n\n// Select Users who have orders &gt; 500\n$users = User::whereExists($orders)-&gt;all();\n</code></pre>"},{"location":"query-builder/#pagination","title":"Pagination","text":"<p>The <code>paginate()</code> method simplifies frontend integration.</p> <pre><code>$result = User::where('active', 1)-&gt;paginate(page: 2, perPage: 15);\n\n// Structure of $result:\n// [\n//    'data' =&gt; [ ... objects ... ],\n//    'total' =&gt; 150,\n//    'per_page' =&gt; 15,\n//    'current_page' =&gt; 2,\n//    'last_page' =&gt; 10\n// ]\n</code></pre>"},{"location":"query-builder/#aggregates","title":"Aggregates","text":""},{"location":"query-builder/#count","title":"<code>count()</code>","text":"<p>Returns the integer count of rows matching the criteria. It automatically modifies the <code>SELECT</code> clause to <code>COUNT(*)</code> temporarily.</p> <pre><code>$count = User::where('age', '&gt;', 18)-&gt;count();\n</code></pre>"},{"location":"query-builder/#exec","title":"<code>exec()</code>","text":"<p>Returns <code>true</code> if at least one row matches. Optimized to fetch only 1 row.</p> <pre><code>if (User::where('email', 'exists@email.com')-&gt;exec()) {\n    echo \"Email taken!\";\n}\n</code></pre>"},{"location":"relationships/","title":"Relationships &amp; Associations","text":"<p>Rubik provides a robust relationship system to link models together. Relationships are defined as methods returning a <code>Relation</code> object.</p>"},{"location":"relationships/#relationship-types","title":"Relationship Types","text":""},{"location":"relationships/#1-hasone-hasmany","title":"1. HasOne / HasMany","text":"<p>The Inverse side holds the foreign key.</p> <ul> <li>Parent: <code>User</code> (ID: 1)</li> <li>Child: <code>Post</code> (user_id: 1)</li> </ul> <p>User Model:</p> <pre><code>public function posts(): HasMany {\n    // (RelatedClass, ForeignKeyOnChild, LocalKeyOnParent)\n    return $this-&gt;hasMany(Post::class, 'user_id', 'id');\n}\n</code></pre>"},{"location":"relationships/#2-belongsto","title":"2. BelongsTo","text":"<p>The Owning side holds the foreign key.</p> <p>Post Model:</p> <pre><code>public function user(): BelongsTo {\n    // (RelatedClass, ForeignKeyOnThis, OwnerKeyOnParent)\n    return $this-&gt;belongsTo(User::class, 'user_id', 'id');\n}\n</code></pre>"},{"location":"relationships/#3-belongstomany-many-to-many","title":"3. BelongsToMany (Many-to-Many)","text":"<p>Requires a Pivot Table (e.g., <code>role_user</code>).</p> <p>User Model:</p> <pre><code>public function roles(): BelongsToMany {\n    return $this-&gt;belongsToMany(\n        related: Role::class,\n        pivotTable: 'role_user',\n        foreignKey: 'user_id',    // Key in pivot pointing to This\n        relatedKey: 'role_id',    // Key in pivot pointing to Related\n        parentKey: 'id',          // Key on This\n        relatedParentKey: 'id'    // Key on Related\n    );\n}\n</code></pre> <p>Pivot Table Names</p> <p>Unlike some ORMs, Rubik requires you to explicitly name the pivot table. It does not guess alphabetical order (e.g., <code>role_user</code> vs <code>user_role</code>).</p>"},{"location":"relationships/#loading-strategies","title":"Loading Strategies","text":""},{"location":"relationships/#lazy-loading-magic-property","title":"Lazy Loading (Magic Property)","text":"<p>Accessing the relationship as a property triggers a database query immediately. The result is cached on the model instance.</p> <pre><code>$user = User::find(1);\n// Query runs here: SELECT * FROM posts WHERE user_id = 1\n$posts = $user-&gt;posts;\n</code></pre>"},{"location":"relationships/#eager-loading-with","title":"Eager Loading (<code>with</code>)","text":"<p>Solves the N+1 query problem. Rubik loads all related models in one go and maps them in memory.</p> <pre><code>$users = User::query()-&gt;with('posts', 'profile')-&gt;all();\n\nforeach ($users as $user) {\n    // No DB query here. $user-&gt;posts is already populated.\n    print_r($user-&gt;posts);\n}\n</code></pre>"},{"location":"relationships/#how-eager-loading-works-internally","title":"How Eager Loading Works Internally","text":"<ol> <li>Extract Keys: Rubik gathers all IDs from the parent <code>$users</code> list.</li> <li>Batch Query: It runs <code>SELECT * FROM posts WHERE user_id IN (1, 2, 3...)</code>.</li> <li>Dictionary Map: It iterates the posts, grouping them by <code>user_id</code>.</li> <li>Hydration: It assigns the groups back to the specific User instances using <code>setRelation()</code>.</li> </ol>"},{"location":"relationships/#chaining-on-relations","title":"Chaining on Relations","text":"<p>Since Relationships act as Query Builders, you can refine them:</p> <pre><code>// Get only published posts for this user\n$published = $user-&gt;posts()-&gt;where('status', 'published')-&gt;get();\n</code></pre>"},{"location":"schema-definition/","title":"Schema Definition &amp; Migrations","text":"<p>Rubik uses a powerful \"Code-First\" approach. You define your schema using the <code>fields()</code> method within your Model. This allows you to generate, truncate, and drop tables programmatically.</p>"},{"location":"schema-definition/#the-fields-method","title":"The <code>fields()</code> Method","text":"<p>Every model must implement this method. It returns an associative array where:</p> <ul> <li>Key: The column name in the database.</li> <li>Value: An array definition returned by the <code>Column</code> class helper.</li> </ul> <pre><code>protected static function fields(): array\n{\n    return [\n        'id'         =&gt; Column::Integer(primaryKey: true, autoIncrement: true),\n        'created_at' =&gt; Column::DateTime(default: SQL::raw('CURRENT_TIMESTAMP')),\n    ];\n}\n</code></pre>"},{"location":"schema-definition/#the-column-factory","title":"The <code>Column</code> Factory","text":"<p>The <code>AdaiasMagdiel\\Rubik\\Column</code> class is a smart factory. It validates your inputs and maps logical types to driver-specific SQL types.</p>"},{"location":"schema-definition/#available-types-logic","title":"Available Types &amp; Logic","text":"Method SQLite Mapping MySQL Mapping Validation Rules <code>Integer</code> <code>INTEGER</code> <code>INTEGER</code> Default must be int. <code>BigInt</code> <code>INTEGER</code> <code>BIGINT</code> - <code>TinyInt</code> <code>INTEGER</code> <code>TINYINT</code> Range check (-128 to 127 or 0-255). <code>Decimal</code> <code>NUMERIC</code> <code>DECIMAL(p,s)</code> Validates precision/scale/max values. <code>Boolean</code> <code>INTEGER</code> <code>TINYINT(1)</code> Default must be boolean or 0/1. <code>Varchar</code> <code>TEXT</code> <code>VARCHAR(n)</code> Length 1-65535. <code>Text</code> <code>TEXT</code> <code>TEXT</code> - <code>Enum</code> <code>TEXT</code> <code>ENUM(...)</code> <code>values</code> array cannot be empty. <code>Json</code> <code>TEXT</code> <code>JSON</code> Validates default JSON structure. <code>Uuid</code> <code>TEXT</code> <code>CHAR(36)</code> Validates RFC 4122 format. <code>DateTime</code> <code>TEXT</code> <code>DATETIME</code> Precision 0-6."},{"location":"schema-definition/#common-arguments","title":"Common Arguments","text":"<p>All <code>Column</code> methods accept these named arguments:</p> <ul> <li><code>primaryKey</code> (bool): Marks column as PK.</li> <li><code>notNull</code> (bool): Adds <code>NOT NULL</code>.</li> <li><code>unique</code> (bool): Adds <code>UNIQUE</code> constraint.</li> <li><code>default</code> (mixed): The default value (literal or <code>SQL::raw</code>).</li> <li><code>autoIncrement</code> (bool): For integer types.</li> </ul>"},{"location":"schema-definition/#foreign-keys","title":"Foreign Keys","text":"<p>Use the <code>Column::ForeignKey</code> helper to define relations inside the column definition.</p> <pre><code>'user_id' =&gt; Column::Integer(\n    notNull: true,\n    foreignKey: Column::ForeignKey(\n        references: 'id',\n        table: 'users',\n        onDelete: 'CASCADE',\n        onUpdate: 'NO ACTION'\n    )\n)\n</code></pre> <p>Driver Awareness</p> <p>SQLite creates Foreign Keys inline during <code>CREATE TABLE</code>. If you are using SQLite, make sure your tables are created in the correct order (Parents before Children) to satisfy constraint checks.</p>"},{"location":"schema-definition/#ddl-operations","title":"DDL Operations","text":"<p>The <code>SchemaTrait</code> provides static methods to manipulate the database structure based on your definition.</p>"},{"location":"schema-definition/#create-table","title":"Create Table","text":"<pre><code>// Generates CREATE TABLE IF NOT EXISTS users (...)\nUser::createTable(ifNotExists: true);\n</code></pre>"},{"location":"schema-definition/#drop-table","title":"Drop Table","text":"<pre><code>// Generates DROP TABLE IF EXISTS users\nUser::dropTable(ifExists: true);\n</code></pre>"},{"location":"schema-definition/#truncate-table","title":"Truncate Table","text":"<p>Provides a unified interface for clearing data.</p> <ul> <li>MySQL: Executes <code>TRUNCATE TABLE</code>.</li> <li>SQLite: Executes <code>DELETE FROM</code> (as TRUNCATE is not supported) and optimizes <code>autoincrement</code>.</li> </ul> <pre><code>User::truncateTable();\n</code></pre>"}]}