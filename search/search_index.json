{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Rubik ORM","text":"<p>Rubik ORM is a lightweight, driver-aware Object\u2013Relational Mapper for PHP that seamlessly adapts to SQLite and MySQL/MariaDB environments \u2014 providing a fluent, expressive, and safe abstraction for database modeling, querying, and schema management.</p>"},{"location":"#overview","title":"\ud83d\ude80 Overview","text":"<p>Rubik ORM brings the power of modern ORMs to a compact and dependency-free package. It is designed to be fast, predictable, and driver-aware \u2014 automatically adapting SQL syntax and behavior depending on the active database driver.</p>"},{"location":"#key-features","title":"\u2728 Key Features","text":"<ul> <li>Driver-aware design \u2014 supports both SQLite and MySQL/MariaDB, automatically adjusting types and syntax.</li> <li>Lightweight and dependency-free \u2014 built with native PDO under the hood.</li> <li>Schema builder \u2014 programmatically define and create database schemas in PHP.</li> <li>Query builder \u2014 build expressive SQL queries fluently with chainable methods.</li> <li>Model abstraction \u2014 define models that map directly to database tables.</li> <li>Relationships \u2014 define <code>belongsTo</code>, <code>hasOne</code>, <code>hasMany</code>, and <code>belongsToMany</code> associations.</li> <li>Type-safe columns \u2014 via <code>Column</code> definitions and extensive validation.</li> <li>Raw SQL support \u2014 safely inject raw SQL fragments using <code>SQL::raw()</code>.</li> <li>Portable \u2014 works seamlessly across CLI scripts, REST APIs, and traditional web apps.</li> <li>Test-friendly \u2014 designed to work easily with in-memory SQLite databases.</li> </ul>"},{"location":"#example","title":"\ud83e\udde9 Example","text":"<p>Here's a minimal example of Rubik ORM in action:</p> <pre><code>&lt;?php\n\nuse AdaiasMagdiel\\Rubik\\Rubik;\nuse AdaiasMagdiel\\Rubik\\Enum\\Driver;\nuse AdaiasMagdiel\\Rubik\\Model;\nuse AdaiasMagdiel\\Rubik\\Column;\nuse AdaiasMagdiel\\Rubik\\SQL;\n\n// 1. Connect to an in-memory SQLite database\nRubik::connect(Driver::SQLITE, path: ':memory:');\n\n// 2. Define a model\nclass User extends Model {\n    protected static string $table = 'users';\n\n    protected static function fields(): array {\n        return [\n            'id' =&gt; Column::Integer(primaryKey: true, autoincrement: true),\n            'name' =&gt; Column::Varchar(length: 100, notNull: true),\n            'email' =&gt; Column::Varchar(length: 150, notNull: true, unique: true),\n            'created_at' =&gt; Column::Datetime(default: SQL::raw('CURRENT_TIMESTAMP')),\n        ];\n    }\n}\n\n// 3. Create the table\nUser::createTable();\n\n// 4. Create and save a user\n$user = new User();\n$user-&gt;name = 'Ada\u00edas Magdiel';\n$user-&gt;email = 'adaias@example.com';\n$user-&gt;save();\n\n// 5. Fetch the user\n$found = User::find(1);\necho $found-&gt;name; // Ada\u00edas Magdiel\n</code></pre>"},{"location":"#requirements","title":"\ud83d\udce6 Requirements","text":"<ul> <li>PHP 8.1 or higher</li> <li>PDO extension enabled</li> <li>Compatible with SQLite 3 and MySQL/MariaDB</li> </ul>"},{"location":"#installation","title":"\ud83e\uddf0 Installation","text":"<p>Install via Composer:</p> <pre><code>composer require adaiasmagdiel/rubik-orm\n</code></pre>"},{"location":"#documentation-structure","title":"\ud83e\udded Documentation Structure","text":"Section Description Getting Started Install Rubik and connect to your first database Configuration Driver setup, environment configuration, and options Models Define models and manage data records Query Builder Build fluent SQL queries Relationships Define associations between models SQL Raw Expressions Use <code>SQL::raw()</code> safely API Reference Complete API documentation"},{"location":"#license","title":"\u2696\ufe0f License","text":"<p>Rubik ORM is open-source software licensed under the GPLv3 License. See the LICENSE file for details.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>Rubik ORM is built on top of PHP\u2019s PDO extension and provides a unified configuration interface through the static method:</p> <pre><code>Rubik::connect()\n</code></pre> <p>This page explains how to configure and manage database connections for SQLite and MySQL/MariaDB, including available parameters, environment setup, and best practices.</p>"},{"location":"configuration/#basic-connection","title":"\u2699\ufe0f Basic Connection","text":"<p>All connections are created via:</p> <pre><code>Rubik::connect(\n    driver: Driver::SQLITE | Driver::MYSQL,\n    username: string = '',\n    password: string = '',\n    database: string = '',\n    port: int = 3306,\n    host: string = 'localhost',\n    charset: string = 'utf8mb4',\n    path: string = ':memory:',\n    options: array = []\n): void\n</code></pre> <p>You can call this method once per request \u2014 Rubik manages a static internal connection that all models and queries share.</p>"},{"location":"configuration/#supported-drivers","title":"\ud83e\udde9 Supported Drivers","text":"Driver Enum Description Example <code>Driver::SQLITE</code> Local file or in-memory SQLite database <code>Rubik::connect(Driver::SQLITE, path: ':memory:');</code> <code>Driver::MYSQL</code> MySQL or MariaDB server connection <code>Rubik::connect(Driver::MYSQL, username: 'root', password: 'secret', database: 'app');</code> <p>Rubik automatically adapts:</p> <ul> <li>SQL type definitions</li> <li>Column syntax (<code>AUTO_INCREMENT</code>, <code>AUTOINCREMENT</code>, etc.)</li> <li>Table creation and default value handling</li> </ul>"},{"location":"configuration/#sqlite-configuration","title":"\ud83d\uddc4\ufe0f SQLite Configuration","text":"<p>SQLite is the simplest option for local development and testing.</p>"},{"location":"configuration/#example","title":"Example","text":"<pre><code>use AdaiasMagdiel\\Rubik\\Rubik;\nuse AdaiasMagdiel\\Rubik\\Enum\\Driver;\n\nRubik::connect(\n    driver: Driver::SQLITE,\n    path: ':memory:' // or '/absolute/path/to/database.sqlite'\n);\n</code></pre>"},{"location":"configuration/#notes","title":"Notes","text":"<ul> <li>Use <code>:memory:</code> for ephemeral test databases.</li> <li>SQLite automatically creates the file if it does not exist.</li> <li>Rubik automatically enables foreign key constraints via <code>PRAGMA foreign_keys = ON;</code>.</li> </ul>"},{"location":"configuration/#mysql-mariadb-configuration","title":"\ud83d\udc2c MySQL / MariaDB Configuration","text":"<p>For production and network-based databases, use the MySQL driver.</p>"},{"location":"configuration/#example_1","title":"Example","text":"<pre><code>use AdaiasMagdiel\\Rubik\\Rubik;\nuse AdaiasMagdiel\\Rubik\\Enum\\Driver;\n\nRubik::connect(\n    driver: Driver::MYSQL,\n    username: 'root',\n    password: 'secret',\n    database: 'rubik_app',\n    host: '127.0.0.1',\n    port: 3306,\n    charset: 'utf8mb4'\n);\n</code></pre>"},{"location":"configuration/#parameters-reference","title":"Parameters Reference","text":"Parameter Type Default Description <code>driver</code> <code>Driver</code> enum \u2014 <code>Driver::MYSQL</code> or <code>Driver::SQLITE</code> <code>username</code> <code>string</code> <code>''</code> Database username <code>password</code> <code>string</code> <code>''</code> Database password <code>database</code> <code>string</code> <code>''</code> Database name <code>port</code> <code>int</code> <code>3306</code> Connection port <code>host</code> <code>string</code> <code>'localhost'</code> Database host <code>charset</code> <code>string</code> <code>'utf8mb4'</code> Connection charset <code>path</code> <code>string</code> <code>':memory:'</code> SQLite path only <code>options</code> <code>array</code> <code>[]</code> Extra PDO options"},{"location":"configuration/#advanced-pdo-options","title":"\u2699\ufe0f Advanced PDO Options","text":"<p>Rubik merges your custom <code>$options</code> array with its internal defaults:</p> <pre><code>[\n    PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION,\n    PDO::ATTR_DEFAULT_FETCH_MODE =&gt; PDO::FETCH_ASSOC,\n    PDO::ATTR_EMULATE_PREPARES =&gt; false,\n    PDO::ATTR_STRINGIFY_FETCHES =&gt; false,\n]\n</code></pre> <p>You can override or extend them as needed:</p> <pre><code>Rubik::connect(\n    driver: Driver::MYSQL,\n    username: 'root',\n    password: '',\n    database: 'mydb',\n    options: [\n        PDO::ATTR_TIMEOUT =&gt; 5,\n        PDO::ATTR_PERSISTENT =&gt; true,\n    ]\n);\n</code></pre>"},{"location":"configuration/#checking-connection-status","title":"\ud83e\udde0 Checking Connection Status","text":"<p>Rubik offers helper methods to inspect or manage the current database connection.</p> <pre><code>use AdaiasMagdiel\\Rubik\\Rubik;\n\n// Check if a connection is active\nif (Rubik::isConnected()) {\n    echo \"Connected!\";\n}\n\n// Get the underlying PDO instance\n$pdo = Rubik::getConn();\n\n// Get the active driver (Driver enum)\n$driver = Rubik::getDriver();\n\n// Disconnect manually\nRubik::disconnect();\n</code></pre>"},{"location":"configuration/#forcing-a-driver-testing-only","title":"\u26a1 Forcing a Driver (Testing Only)","text":"<p>You can force a driver without opening a connection \u2014 useful for testing type behavior or SQL generation:</p> <pre><code>use AdaiasMagdiel\\Rubik\\Rubik;\nuse AdaiasMagdiel\\Rubik\\Enum\\Driver;\n\nRubik::setDriver(Driver::MYSQL);\n</code></pre> <p>\u26a0\ufe0f Note: <code>setDriver()</code> does not create a real PDO connection \u2014 it only overrides the internal driver used for SQL dialect logic.</p>"},{"location":"configuration/#example-multiple-environments","title":"\ud83e\uddf1 Example: Multiple Environments","text":"<p>A common approach is to load connection settings from <code>.env</code> files or environment variables:</p> <pre><code>use AdaiasMagdiel\\Rubik\\Rubik;\nuse AdaiasMagdiel\\Rubik\\Enum\\Driver;\n\n$env = getenv('APP_ENV') ?: 'development';\n\nif ($env === 'production') {\n    Rubik::connect(\n        driver: Driver::MYSQL,\n        username: getenv('DB_USER'),\n        password: getenv('DB_PASS'),\n        database: getenv('DB_NAME'),\n        host: getenv('DB_HOST') ?: '127.0.0.1'\n    );\n} else {\n    Rubik::connect(Driver::SQLITE, path: __DIR__ . '/../database/dev.sqlite');\n}\n</code></pre> <p>This allows Rubik to automatically select the right database configuration depending on the runtime environment.</p>"},{"location":"configuration/#example-in-memory-sqlite-for-testing","title":"\ud83e\udde9 Example: In-Memory SQLite for Testing","text":"<pre><code>use AdaiasMagdiel\\Rubik\\Rubik;\nuse AdaiasMagdiel\\Rubik\\Enum\\Driver;\n\nRubik::connect(Driver::SQLITE, path: ':memory:');\n\n// Prepare schema for tests\nUser::createTable();\nPost::createTable();\n</code></pre> <p>Perfect for unit testing and continuous integration setups.</p>"},{"location":"configuration/#common-connection-errors","title":"\ud83e\uddf0 Common Connection Errors","text":"Error Possible Cause Fix <code>No active database connection</code> <code>Rubik::connect()</code> was never called Ensure connection is established before any model action <code>Unsupported database driver</code> Using a non-implemented driver (e.g. PostgreSQL) Currently only <code>MYSQL</code> and <code>SQLITE</code> are supported <code>SQLSTATE[HY000]: unable to open database file</code> Invalid SQLite path Use an absolute path or ensure directory permissions <code>Access denied for user</code> Wrong credentials for MySQL Check username/password or host in your configuration"},{"location":"configuration/#summary","title":"\ud83e\uddfe Summary","text":"<p>Rubik ORM abstracts all connection complexity while keeping full control over the underlying PDO layer.</p> <p>\u2705 Key takeaways:</p> <ul> <li>Use <code>Rubik::connect()</code> before interacting with any model or query.</li> <li><code>Driver::SQLITE</code> is ideal for local or test setups.</li> <li><code>Driver::MYSQL</code> is ideal for production environments.</li> <li>Rubik automatically manages and caches a single global connection.</li> <li>You can inspect, override, or close it at any time.</li> </ul>"},{"location":"configuration/#next-steps","title":"\ud83e\udded Next Steps","text":"<p>Continue with:</p> <ul> <li>Database Connections \u2014 deeper insight into connection management</li> <li>Models \u2014 defining and mapping your data models</li> </ul>"},{"location":"connections/","title":"Database Connections","text":"<p>Rubik ORM uses PHP\u2019s PDO engine to manage database connections in a consistent and driver-aware way. It simplifies the connection lifecycle \u2014 from establishing and checking connections to managing multiple databases for different environments.</p>"},{"location":"connections/#overview","title":"\ud83d\udd0c Overview","text":"<p>Rubik maintains a single global PDO connection internally, which all models and query builders share. This means you don\u2019t need to manually pass the connection object \u2014 once you call:</p> <pre><code>Rubik::connect(...)\n</code></pre> <p>All subsequent ORM operations (queries, models, schema builders) will automatically use the same connection.</p>"},{"location":"connections/#the-connection-lifecycle","title":"\u2699\ufe0f The Connection Lifecycle","text":"<ol> <li>Connect using <code>Rubik::connect()</code></li> <li>Execute queries using models or the query builder</li> <li>Check connection with <code>Rubik::isConnected()</code></li> <li>Disconnect with <code>Rubik::disconnect()</code></li> </ol> <p>Example:</p> <pre><code>use AdaiasMagdiel\\Rubik\\Rubik;\nuse AdaiasMagdiel\\Rubik\\Enum\\Driver;\n\n// 1. Connect\nRubik::connect(Driver::SQLITE, path: ':memory:');\n\n// 2. Perform database actions\nUser::createTable();\nUser::query()-&gt;where('id', 1)-&gt;first();\n\n// 3. Check connection\nif (Rubik::isConnected()) {\n    echo \"Connection is active.\";\n}\n\n// 4. Disconnect\nRubik::disconnect();\n</code></pre>"},{"location":"connections/#the-rubik-connection-api","title":"\ud83e\udde9 The Rubik Connection API","text":"<p>Rubik provides several static methods to manage and inspect the current connection.</p> Method Description Return Type <code>Rubik::connect(...)</code> Opens a PDO connection and sets the current driver <code>void</code> <code>Rubik::getConn()</code> Returns the current PDO instance <code>PDO</code> <code>Rubik::isConnected()</code> Checks if a connection is currently active <code>bool</code> <code>Rubik::getDriver()</code> Returns the current driver enum <code>Driver</code> <code>Rubik::disconnect()</code> Closes the active connection <code>void</code> <code>Rubik::setDriver($driver)</code> Manually sets a driver without connecting (for testing) <code>void</code>"},{"location":"connections/#inspecting-the-current-connection","title":"\ud83e\udde0 Inspecting the Current Connection","text":"<p>You can retrieve the underlying PDO object to perform raw SQL queries or low-level operations.</p> <pre><code>$pdo = Rubik::getConn();\n\n$stmt = $pdo-&gt;query('SELECT sqlite_version()');\necho $stmt-&gt;fetchColumn();\n</code></pre> <p>Rubik\u2019s PDO instance is configured with sensible defaults:</p> <pre><code>PDO::ATTR_ERRMODE            =&gt; PDO::ERRMODE_EXCEPTION\nPDO::ATTR_DEFAULT_FETCH_MODE =&gt; PDO::FETCH_ASSOC\nPDO::ATTR_EMULATE_PREPARES   =&gt; false\nPDO::ATTR_STRINGIFY_FETCHES  =&gt; false\n</code></pre> <p>These ensure robust error handling and consistent typing.</p>"},{"location":"connections/#using-multiple-databases","title":"\u2699\ufe0f Using Multiple Databases","text":"<p>Rubik ORM is designed to maintain one active connection at a time. If you need to interact with multiple databases, you can swap connections on the fly:</p> <pre><code>use AdaiasMagdiel\\Rubik\\Rubik;\nuse AdaiasMagdiel\\Rubik\\Enum\\Driver;\n\n// Connect to SQLite\nRubik::connect(Driver::SQLITE, path: 'database.sqlite');\n\n// Run queries on SQLite\nUser::createTable();\n\n// Switch to MySQL\nRubik::connect(\n    Driver::MYSQL,\n    username: 'root',\n    password: '',\n    database: 'rubik_production'\n);\n\n// Now all models and queries use MySQL\nUser::createTable();\n</code></pre>"},{"location":"connections/#tip","title":"\ud83d\udca1 Tip","text":"<p>For multi-database applications, wrap your connection logic in a custom class or helper function:</p> <pre><code>function connectTo(string $env): void {\n    match ($env) {\n        'testing' =&gt; Rubik::connect(Driver::SQLITE, path: ':memory:'),\n        'local'   =&gt; Rubik::connect(Driver::SQLITE, path: __DIR__ . '/../db/local.sqlite'),\n        'prod'    =&gt; Rubik::connect(Driver::MYSQL, username: 'root', password: 'secret', database: 'prod_db'),\n        default   =&gt; throw new RuntimeException(\"Unknown environment: {$env}\")\n    };\n}\n</code></pre>"},{"location":"connections/#connection-persistence","title":"\ud83e\uddee Connection Persistence","text":"<p>Each call to <code>Rubik::connect()</code> creates a new PDO connection.</p> <p>If you need persistent connections, you can enable it via the <code>$options</code> array:</p> <pre><code>Rubik::connect(\n    driver: Driver::MYSQL,\n    username: 'root',\n    password: '',\n    database: 'rubik',\n    options: [\n        PDO::ATTR_PERSISTENT =&gt; true\n    ]\n);\n</code></pre> <p>\u26a0\ufe0f Use persistent connections with caution in environments where database state may persist across requests (e.g. long-running PHP daemons).</p>"},{"location":"connections/#custom-pdo-options","title":"\ud83e\uddfe Custom PDO Options","text":"<p>Rubik lets you fully control PDO behavior via the <code>$options</code> parameter of <code>connect()</code>:</p> <pre><code>Rubik::connect(\n    driver: Driver::MYSQL,\n    username: 'root',\n    password: '',\n    database: 'rubik',\n    options: [\n        PDO::ATTR_TIMEOUT =&gt; 5,\n        PDO::MYSQL_ATTR_INIT_COMMAND =&gt; \"SET NAMES 'utf8mb4'\"\n    ]\n);\n</code></pre> <p>The provided array merges with Rubik\u2019s defaults, ensuring safe operation.</p>"},{"location":"connections/#testing-database-connections","title":"\ud83e\uddea Testing Database Connections","text":"<p>You can quickly verify connectivity using PHP exceptions:</p> <pre><code>try {\n    Rubik::connect(Driver::MYSQL, username: 'root', password: 'wrong');\n} catch (RuntimeException $e) {\n    echo \"Connection failed: \" . $e-&gt;getMessage();\n}\n</code></pre> <p>For SQLite, most issues occur due to invalid file paths or permissions:</p> <pre><code>Rubik::connect(Driver::SQLITE, path: '/invalid/path/data.sqlite');\n// Throws: RuntimeException(\"Failed to connect to database: unable to open database file\")\n</code></pre>"},{"location":"connections/#connection-states-and-errors","title":"\ud83e\udded Connection States and Errors","text":"Error Message Meaning Typical Fix <code>No active database connection</code> You\u2019re trying to use a model before connecting Call <code>Rubik::connect()</code> first <code>Unsupported database driver</code> You passed an invalid <code>Driver</code> enum Use <code>Driver::MYSQL</code> or <code>Driver::SQLITE</code> only <code>Failed to connect to database</code> PDO connection error Check credentials or path <code>SQLSTATE[HY000]</code> errors SQL syntax or engine issues Validate your queries and schema <p>Rubik wraps all PDO exceptions in <code>RuntimeException</code> to ensure consistent error reporting.</p>"},{"location":"connections/#connection-validation-example","title":"\ud83e\udde9 Connection Validation Example","text":"<p>You can easily build an environment checker to confirm that Rubik ORM is ready:</p> <pre><code>use AdaiasMagdiel\\Rubik\\Rubik;\nuse AdaiasMagdiel\\Rubik\\Enum\\Driver;\n\ntry {\n    Rubik::connect(Driver::MYSQL, username: 'root', password: '', database: 'rubik_test');\n    echo \"\u2705 Connected to MySQL successfully.\\n\";\n    echo \"Driver: \" . Rubik::getDriver()-&gt;value;\n} catch (RuntimeException $e) {\n    echo \"\u274c Database connection failed: \" . $e-&gt;getMessage();\n}\n</code></pre>"},{"location":"connections/#example-switching-between-memory-and-file-based-sqlite","title":"\ud83e\uddf1 Example: Switching Between Memory and File-Based SQLite","text":"<pre><code>use AdaiasMagdiel\\Rubik\\Rubik;\nuse AdaiasMagdiel\\Rubik\\Enum\\Driver;\n\n// Use an in-memory database for testing\nRubik::connect(Driver::SQLITE, path: ':memory:');\nUser::createTable();\n\n// Populate test data\nUser::insertMany([\n    ['name' =&gt; 'Alice'],\n    ['name' =&gt; 'Bob']\n]);\n\n// Switch to file-based SQLite\nRubik::connect(Driver::SQLITE, path: __DIR__ . '/database.sqlite');\n\n// Persisted data can be managed independently\nUser::createTable(ifNotExists: true);\n</code></pre>"},{"location":"connections/#example-manual-pdo-query-execution","title":"\ud83e\uddf0 Example: Manual PDO Query Execution","text":"<p>If you need direct access to SQL (e.g., migrations or analytics), you can always fall back to raw PDO:</p> <pre><code>$pdo = Rubik::getConn();\n\n$stmt = $pdo-&gt;prepare('SELECT COUNT(*) FROM users');\n$stmt-&gt;execute();\n\n$count = $stmt-&gt;fetchColumn();\necho \"Total users: {$count}\";\n</code></pre> <p>Rubik is intentionally designed to coexist with direct PDO usage \u2014 no hidden magic, no blocking abstractions.</p>"},{"location":"connections/#summary","title":"\ud83e\uddfe Summary","text":"<p>\u2705 Key takeaways:</p> <ul> <li>Rubik maintains a single shared PDO connection</li> <li>Always call <code>Rubik::connect()</code> before using models or queries</li> <li>Switch databases by reconnecting with different drivers</li> <li>Manage persistence, options, and environments flexibly</li> <li>Access <code>Rubik::getConn()</code> for full PDO control</li> <li>Use exceptions to handle connection failures cleanly</li> </ul>"},{"location":"connections/#next-steps","title":"\ud83e\udded Next Steps","text":"<p>Continue with:</p> <ul> <li>Models \u2014 defining tables, fields, and relationships</li> <li>Query Builder \u2014 building advanced, fluent SQL queries</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to Rubik ORM \u2014 a fast, lightweight, and driver-aware ORM for PHP. This guide will walk you through installation, configuration, and your first working model.</p>"},{"location":"getting-started/#installation","title":"\ud83e\uddf0 Installation","text":"<p>You can install Rubik ORM using Composer:</p> <pre><code>composer require adaiasmagdiel/rubik-orm\n</code></pre> <p>Ensure that you have:</p> <ul> <li>PHP \u2265 8.1</li> <li>The PDO extension enabled</li> <li> <p>One of the supported database drivers:</p> </li> <li> <p><code>pdo_sqlite</code></p> </li> <li><code>pdo_mysql</code></li> </ul>"},{"location":"getting-started/#connecting-to-a-database","title":"\u2699\ufe0f Connecting to a Database","text":"<p>Before interacting with models, Rubik must be connected to a database using the static <code>Rubik::connect()</code> method.</p>"},{"location":"getting-started/#example-sqlite-recommended-for-testing","title":"Example: SQLite (Recommended for Testing)","text":"<pre><code>use AdaiasMagdiel\\Rubik\\Rubik;\nuse AdaiasMagdiel\\Rubik\\Enum\\Driver;\n\nRubik::connect(\n    driver: Driver::SQLITE,\n    path: ':memory:' // or '/path/to/database.sqlite'\n);\n</code></pre>"},{"location":"getting-started/#example-mysql-mariadb","title":"Example: MySQL / MariaDB","text":"<pre><code>use AdaiasMagdiel\\Rubik\\Rubik;\nuse AdaiasMagdiel\\Rubik\\Enum\\Driver;\n\nRubik::connect(\n    driver: Driver::MYSQL,\n    username: 'root',\n    password: 'secret',\n    database: 'rubik_demo',\n    host: '127.0.0.1',\n    port: 3306\n);\n</code></pre> <p>Rubik automatically adapts column types and SQL syntax depending on the active driver.</p>"},{"location":"getting-started/#creating-a-model","title":"\ud83e\uddf1 Creating a Model","text":"<p>Models represent database tables. Each model must extend the <code>Rubik\\Model</code> class and define two methods:</p> <ul> <li><code>protected static string $table</code> \u2014 the table name</li> <li><code>protected static function fields(): array</code> \u2014 the column schema</li> </ul> <p>Example:</p> <pre><code>use AdaiasMagdiel\\Rubik\\Model;\nuse AdaiasMagdiel\\Rubik\\Column;\nuse AdaiasMagdiel\\Rubik\\SQL;\n\nclass User extends Model\n{\n    protected static string $table = 'users';\n\n    protected static function fields(): array\n    {\n        return [\n            'id' =&gt; Column::Integer(primaryKey: true, autoincrement: true),\n            'name' =&gt; Column::Varchar(length: 100, notNull: true),\n            'email' =&gt; Column::Varchar(length: 150, notNull: true, unique: true),\n            'created_at' =&gt; Column::Datetime(default: SQL::raw('CURRENT_TIMESTAMP')),\n        ];\n    }\n}\n</code></pre>"},{"location":"getting-started/#creating-tables","title":"\ud83c\udfd7\ufe0f Creating Tables","text":"<p>Once your model is defined, you can generate its corresponding table:</p> <pre><code>User::createTable(ifNotExists: true);\n</code></pre> <p>To reset or remove it:</p> <pre><code>User::truncateTable(); // removes all rows\nUser::dropTable(ifExists: true); // drops the table\n</code></pre>"},{"location":"getting-started/#inserting-records","title":"\ud83d\udcbe Inserting Records","text":"<p>Rubik models work like simple data containers:</p> <pre><code>$user = new User();\n$user-&gt;name = 'Ada\u00edas Magdiel';\n$user-&gt;email = 'adaias@example.com';\n$user-&gt;save();\n</code></pre>"},{"location":"getting-started/#querying-data","title":"\ud83d\udd0d Querying Data","text":"<p>Use static methods or the <code>query()</code> builder for full control.</p> <pre><code>// Find by primary key\n$user = User::find(1);\n\n// Get all users\n$users = User::all();\n\n// Fluent query builder\n$filtered = User::query()\n    -&gt;where('email', 'LIKE', '%example.com%')\n    -&gt;orderBy('id', 'DESC')\n    -&gt;limit(5)\n    -&gt;all();\n</code></pre>"},{"location":"getting-started/#updating-and-deleting","title":"\ud83d\udd04 Updating and Deleting","text":"<pre><code>// Update\n$user = User::find(1);\n$user-&gt;name = 'Updated Name';\n$user-&gt;save();\n\n// Delete\n$user-&gt;delete();\n</code></pre>"},{"location":"getting-started/#relationships","title":"\ud83e\udd1d Relationships","text":"<p>Rubik supports standard ORM relationships:</p> <ul> <li><code>belongsTo</code></li> <li><code>hasOne</code></li> <li><code>hasMany</code></li> <li><code>belongsToMany</code></li> </ul> <p>Example:</p> <pre><code>class Post extends Model {\n    protected static function relationships(): array {\n        return [\n            'author' =&gt; [\n                'type' =&gt; 'belongsTo',\n                'related' =&gt; User::class,\n                'foreignKey' =&gt; 'user_id',\n                'ownerKey' =&gt; 'id',\n            ],\n        ];\n    }\n}\n\n$post = Post::find(1);\necho $post-&gt;author-&gt;name;\n</code></pre>"},{"location":"getting-started/#testing-with-sqlite-memory-databases","title":"\ud83e\uddea Testing with SQLite Memory Databases","text":"<p>Rubik ORM was designed with testing in mind.</p> <p>You can use an in-memory SQLite database to run isolated unit tests quickly:</p> <pre><code>Rubik::connect(Driver::SQLITE, path: ':memory:');\nUser::createTable();\n\n// Run tests freely\n</code></pre> <p>This makes it easy to test models, queries, and relationships without touching a real database.</p>"},{"location":"getting-started/#next-steps","title":"\ud83e\udded Next Steps","text":"<p>Continue exploring Rubik ORM:</p> <ul> <li>Configuration \u2014 customize your connection setup</li> <li>Models \u2014 learn about field definitions, casting, and serialization</li> <li>Query Builder \u2014 advanced querying with joins and pagination</li> <li>Relationships \u2014 define associations between models</li> </ul>"},{"location":"getting-started/#tip","title":"\ud83d\udca1 Tip","text":"<p>If you\u2019re coming from Laravel\u2019s Eloquent, you\u2019ll feel at home. Rubik offers similar patterns with a lighter, more explicit core \u2014 perfect for APIs, CLI tools, and microservices.</p>"},{"location":"getting-started/#license","title":"\ud83e\uddfe License","text":"<p>Rubik ORM is licensed under GPLv3. You are free to use, modify, and distribute it under the same license terms.</p>"},{"location":"models/","title":"Models","text":"<p>Models in Rubik ORM represent database tables and act as structured, object-oriented interfaces for your data.</p> <p>Each model defines its table name, schema fields, and optionally relationships to other models.</p> <p>Rubik models are lightweight, driver-aware, and rely directly on PDO for efficiency and portability across SQLite and MySQL.</p>"},{"location":"models/#defining-a-model","title":"\ud83e\uddf1 Defining a Model","text":"<p>All models must extend the base <code>AdaiasMagdiel\\Rubik\\Model</code> class and implement the <code>fields()</code> method.</p> <p>A model usually defines:</p> <ul> <li>The static <code>$table</code> property \u2192 name of the database table</li> <li>The <code>fields()</code> method \u2192 columns and their types</li> <li>(Optionally) the <code>relationships()</code> method \u2192 associations with other models</li> </ul> <p>Example:</p> <pre><code>use AdaiasMagdiel\\Rubik\\Model;\nuse AdaiasMagdiel\\Rubik\\Column;\nuse AdaiasMagdiel\\Rubik\\SQL;\n\nclass User extends Model\n{\n    protected static string $table = 'users';\n\n    protected static function fields(): array\n    {\n        return [\n            'id' =&gt; Column::Integer(primaryKey: true, autoincrement: true),\n            'name' =&gt; Column::Varchar(length: 100, notNull: true),\n            'email' =&gt; Column::Varchar(length: 150, notNull: true, unique: true),\n            'created_at' =&gt; Column::Datetime(default: SQL::raw('CURRENT_TIMESTAMP')),\n        ];\n    }\n}\n</code></pre>"},{"location":"models/#table-naming-convention","title":"\u2699\ufe0f Table Naming Convention","text":"<p>If you don\u2019t specify <code>$table</code>, Rubik automatically uses the plural, lowercase form of the class name:</p> <pre><code>class Product extends Model {}\n\necho Product::getTableName(); // \"products\"\n</code></pre> <p>\ud83d\udfe3 It\u2019s a good practice to explicitly define <code>$table</code> for clarity.</p>"},{"location":"models/#field-definitions","title":"\ud83e\udde9 Field Definitions","text":"<p>The <code>fields()</code> method defines a mapping of column names to <code>Column</code> definitions.</p> <p>Each column type is created using <code>Column::Type()</code>, with named arguments for attributes.</p>"},{"location":"models/#example","title":"Example","text":"<pre><code>'price' =&gt; Column::Decimal(precision: 10, scale: 2, default: 0.00, notNull: true),\n'status' =&gt; Column::Enum(values: ['active', 'inactive'], default: 'active'),\n'metadata' =&gt; Column::Json(default: '{}'),\n</code></pre>"},{"location":"models/#available-attributes","title":"Available Attributes","text":"Attribute Type Description <code>primaryKey</code> <code>bool</code> Marks the field as primary key <code>autoincrement</code> <code>bool</code> Enables auto-increment (driver-specific) <code>notNull</code> <code>bool</code> Adds <code>NOT NULL</code> constraint <code>unique</code> <code>bool</code> Adds <code>UNIQUE</code> constraint <code>default</code> <code>mixed</code> Default value (may use <code>SQL::raw()</code> for functions) <code>length</code> <code>int</code> Character limit for strings <code>precision</code>, <code>scale</code> <code>int</code> For numeric types <code>values</code> <code>array</code> For ENUM or SET values <code>foreignKey</code> <code>array</code> Foreign key definition via <code>Column::ForeignKey()</code>"},{"location":"models/#foreign-keys","title":"\ud83d\udd17 Foreign Keys","text":"<p>Rubik supports relational constraints through the <code>Column::ForeignKey()</code> helper. You can attach it directly to a column using the <code>foreignKey:</code> argument.</p>"},{"location":"models/#example_1","title":"Example","text":"<pre><code>'user_id' =&gt; Column::Integer(\n    notNull: true,\n    foreignKey: Column::ForeignKey('id', 'users', 'CASCADE', 'CASCADE')\n),\n</code></pre> <p>This generates a foreign key constraint equivalent to:</p> <pre><code>FOREIGN KEY (user_id)\n  REFERENCES users(id)\n  ON DELETE CASCADE\n  ON UPDATE CASCADE\n</code></pre> <p>Under the hood, <code>Column::ForeignKey()</code> returns a small associative array like:</p> <pre><code>[\n  'foreign_key' =&gt; [\n    'references' =&gt; 'id',\n    'table'      =&gt; 'users',\n    'on_delete'  =&gt; 'CASCADE',\n    'on_update'  =&gt; 'CASCADE'\n  ]\n]\n</code></pre> <p>Rubik merges that automatically into the field definition during table creation.</p>"},{"location":"models/#table-management","title":"\ud83e\uddf0 Table Management","text":"<p>Once defined, you can create or destroy tables directly from your model:</p> <pre><code>User::createTable(ifNotExists: true);  // Creates table if not exists\nUser::truncateTable();                 // Clears all rows\nUser::dropTable(ifExists: true);       // Drops the table\n</code></pre> <p>Rubik automatically handles SQLite\u2019s <code>PRAGMA foreign_keys = ON</code> when needed.</p>"},{"location":"models/#inserting-data","title":"\ud83d\udcbe Inserting Data","text":"<p>To insert new records, simply create an instance and call <code>save()</code>:</p> <pre><code>$user = new User();\n$user-&gt;name = 'Ada\u00edas Magdiel';\n$user-&gt;email = 'adaias@example.com';\n$user-&gt;save();\n</code></pre> <p>Rubik will automatically:</p> <ul> <li>Perform an <code>INSERT</code> if the record doesn\u2019t exist</li> <li>Perform an <code>UPDATE</code> if it does</li> <li>Update the model\u2019s primary key (<code>id</code>) after insert</li> </ul> <p>You can also bulk insert:</p> <pre><code>User::insertMany([\n    ['name' =&gt; 'Alice', 'email' =&gt; 'alice@example.com'],\n    ['name' =&gt; 'Bob', 'email' =&gt; 'bob@example.com'],\n]);\n</code></pre>"},{"location":"models/#updating-data","title":"\u270f\ufe0f Updating Data","text":"<p>To update a record, fetch it, modify attributes, and save again:</p> <pre><code>$user = User::find(1);\n$user-&gt;name = 'Updated Name';\n$user-&gt;save();\n</code></pre> <p>Rubik automatically tracks which fields changed (the <code>_dirty</code> map) and only updates those columns.</p>"},{"location":"models/#deleting-records","title":"\ud83d\uddd1\ufe0f Deleting Records","text":"<pre><code>$user = User::find(1);\n$user-&gt;delete();\n</code></pre>"},{"location":"models/#querying-data","title":"\ud83d\udd0d Querying Data","text":"<p>Each model comes with query methods powered by the internal <code>Query</code> builder:</p> <pre><code>User::all();         // Returns all users\nUser::find(5);       // Finds by primary key\nUser::first();       // Gets the first record\n</code></pre> <p>For advanced queries:</p> <pre><code>$users = User::query()\n    -&gt;where('email', 'LIKE', '%@gmail.com')\n    -&gt;orderBy('id', 'DESC')\n    -&gt;limit(10)\n    -&gt;all();\n</code></pre>"},{"location":"models/#pagination","title":"\ud83e\udded Pagination","text":"<p>Paginate records using:</p> <pre><code>$page = User::paginate(page: 2, perPage: 10);\n\nprint_r($page);\n\n/*\n[\n  'data' =&gt; [...],\n  'total' =&gt; 54,\n  'per_page' =&gt; 10,\n  'current_page' =&gt; 2,\n  'last_page' =&gt; 6\n]\n*/\n</code></pre>"},{"location":"models/#relationships","title":"\ud83e\udd1d Relationships","text":"<p>Rubik supports four relationship types:</p> Type Description <code>belongsTo</code> The model belongs to another (foreign key on current model) <code>hasOne</code> The model has one related record <code>hasMany</code> The model has many related records <code>belongsToMany</code> Many-to-many through a pivot table"},{"location":"models/#example_2","title":"Example","text":"<pre><code>class Post extends Model\n{\n    protected static string $table = 'posts';\n\n    protected static function fields(): array\n    {\n        return [\n            'id' =&gt; Column::Integer(primaryKey: true, autoincrement: true),\n            'user_id' =&gt; Column::Integer(\n                notNull: true,\n                foreignKey: Column::ForeignKey('id', 'users', 'CASCADE', 'CASCADE')\n            ),\n            'title' =&gt; Column::Varchar(length: 200, notNull: true),\n            'content' =&gt; Column::Text(),\n            'created_at' =&gt; Column::Datetime(default: SQL::raw('CURRENT_TIMESTAMP')),\n        ];\n    }\n\n    protected static function relationships(): array\n    {\n        return [\n            'author' =&gt; [\n                'type' =&gt; 'belongsTo',\n                'related' =&gt; User::class,\n                'foreignKey' =&gt; 'user_id',\n                'ownerKey' =&gt; 'id'\n            ],\n        ];\n    }\n}\n</code></pre> <p>Usage:</p> <pre><code>$post = Post::find(1);\necho $post-&gt;author-&gt;name;\n</code></pre> <p>Rubik resolves relationships lazily and caches them per model instance.</p>"},{"location":"models/#serialization","title":"\ud83e\uddee Serialization","text":"<p>All models implement <code>JsonSerializable</code>, so they can be directly converted to arrays or JSON.</p> <pre><code>$user = User::find(1);\nprint_r($user-&gt;toArray());\necho json_encode($user);\n</code></pre> <p>Output:</p> <pre><code>{\n  \"id\": 1,\n  \"name\": \"Ada\u00edas Magdiel\",\n  \"email\": \"adaias@example.com\",\n  \"created_at\": \"2025-10-16 12:34:56\"\n}\n</code></pre> <p>\ud83d\udca1 Tip: You may want to reimplement the <code>toArray()</code> method in your model if you need to handle some custom specifics \u2014 for example, hiding sensitive fields, formatting timestamps, or adding computed attributes.</p>"},{"location":"models/#dirty-tracking","title":"\ud83e\udde0 Dirty Tracking","text":"<p>Rubik automatically tracks which fields have been changed since the last save:</p> <pre><code>$user = User::find(1);\n$user-&gt;name = 'Changed';\n$user-&gt;save(); // Only updates 'name'\n</code></pre>"},{"location":"models/#hydration","title":"\u26a1 Hydration","text":"<p>Query results are automatically hydrated into fully functional model instances:</p> <pre><code>$users = User::query()-&gt;where('id', '&lt;', 5)-&gt;all();\n\nforeach ($users as $user) {\n    echo $user-&gt;name;\n}\n</code></pre> <p>Each instance has full access to <code>save()</code>, <code>delete()</code>, <code>toArray()</code>, and relationships.</p>"},{"location":"models/#best-practices","title":"\ud83e\uddfe Best Practices","text":"<p>\u2705 Always define fields explicitly in <code>fields()</code> \u2705 Use <code>SQL::raw()</code> for literal SQL expressions (e.g., <code>CURRENT_TIMESTAMP</code>) \u2705 Always enable foreign keys in SQLite (Rubik does this for you) \u2705 Keep table names lowercase and plural \u2705 Use clear and descriptive field names</p>"},{"location":"models/#next-steps","title":"\ud83e\udded Next Steps","text":"<p>Continue with:</p> <ul> <li>Query Builder \u2192 Fluent SQL generation</li> <li>Relationships \u2192 Detailed guide on associations</li> </ul>"},{"location":"queries/","title":"Query Builder","text":"<p>The Rubik ORM Query Builder provides a fluent, driver-aware API to construct and execute SQL queries programmatically \u2014 while still giving you full control over the final SQL.</p> <p>It supports:</p> <ul> <li><code>SELECT</code>, <code>UPDATE</code>, and <code>DELETE</code> operations</li> <li>Conditions, joins, grouping, ordering, and pagination</li> <li>Automatic hydration into model instances</li> </ul> <p>Rubik\u2019s query builder is intentionally minimal, predictable, and close to SQL, without hiding what\u2019s really happening.</p>"},{"location":"queries/#creating-queries","title":"\ud83e\udde9 Creating Queries","text":"<p>Each model comes with a static <code>query()</code> method that returns a <code>Query</code> instance bound to that model:</p> <pre><code>use App\\Models\\User;\n\n$query = User::query();\n</code></pre> <p>Alternatively, you can manually create a new builder:</p> <pre><code>use AdaiasMagdiel\\Rubik\\Query;\n\n$query = (new Query())-&gt;setModel(User::class);\n</code></pre>"},{"location":"queries/#selecting-data","title":"\ud83c\udfaf Selecting Data","text":"<p>The simplest way to retrieve data:</p> <pre><code>$users = User::query()-&gt;all();\n</code></pre> <p>You can specify selected fields:</p> <pre><code>$users = User::query()\n    -&gt;select(['id', 'name', 'email'])\n    -&gt;all();\n</code></pre> <p>If you omit <code>.select()</code>, Rubik defaults to <code>SELECT *</code>.</p> <p>You can also get only the first record:</p> <pre><code>$user = User::query()-&gt;first();\n</code></pre> <p>Or fetch by primary key (shortcut):</p> <pre><code>$user = User::find(1);\n</code></pre>"},{"location":"queries/#filtering-with-where","title":"\ud83d\udd0d Filtering with <code>where</code>","text":"<p>Rubik provides fluent <code>where()</code> and <code>orWhere()</code> methods.</p>"},{"location":"queries/#examples","title":"Examples","text":"<pre><code>// Simple equals\nUser::query()-&gt;where('id', 1)-&gt;first();\n\n// Custom operator\nUser::query()-&gt;where('age', '&gt;=', 18)-&gt;all();\n\n// Multiple conditions\nUser::query()\n    -&gt;where('country', 'Brazil')\n    -&gt;orWhere('country', 'Portugal')\n    -&gt;all();\n</code></pre> <p>Each call adds a condition with its conjunction (<code>AND</code> or <code>OR</code>). Supported operators: <code>=</code>, <code>&lt;&gt;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>LIKE</code>.</p>"},{"location":"queries/#where-in","title":"\ud83e\uddf0 WHERE IN","text":"<p>Filter values with <code>whereIn()</code>:</p> <pre><code>$users = User::query()\n    -&gt;whereIn('id', [1, 2, 3])\n    -&gt;all();\n</code></pre> <p>Rubik handles placeholder binding safely under the hood.</p>"},{"location":"queries/#ordering-grouping-and-having","title":"\ud83e\uddee Ordering, Grouping, and Having","text":"<p>Order results:</p> <pre><code>User::query()\n    -&gt;orderBy('name', 'ASC')\n    -&gt;orderBy('id', 'DESC')\n    -&gt;all();\n</code></pre> <p>Group and filter aggregates:</p> <pre><code>User::query()\n    -&gt;select(['country', 'COUNT(*) AS total'])\n    -&gt;groupBy('country')\n    -&gt;having('COUNT(*) &gt; 10')\n    -&gt;orderBy('total', 'DESC')\n    -&gt;all();\n</code></pre>"},{"location":"queries/#joins","title":"\ud83d\udd17 Joins","text":"<p>Rubik supports <code>INNER JOIN</code>, <code>LEFT JOIN</code>, and <code>RIGHT JOIN</code>:</p> <pre><code>User::query()\n    -&gt;join('posts', 'users.id', '=', 'posts.user_id')\n    -&gt;select(['users.name', 'posts.title'])\n    -&gt;all();\n</code></pre>"},{"location":"queries/#available-join-methods","title":"Available join methods","text":"Method Description <code>join($table, $left, $op, $right)</code> Standard INNER JOIN <code>leftJoin($table, $left, $op, $right)</code> LEFT JOIN <code>rightJoin($table, $left, $op, $right)</code> RIGHT JOIN <p>\ud83d\udca1 You can chain multiple joins for complex queries.</p>"},{"location":"queries/#limits-and-offsets","title":"\ud83e\uddfe Limits and Offsets","text":"<p>Limit and offset your results easily:</p> <pre><code>User::query()\n    -&gt;orderBy('id')\n    -&gt;limit(10)\n    -&gt;offset(20)\n    -&gt;all();\n</code></pre>"},{"location":"queries/#pagination","title":"\ud83e\udded Pagination","text":"<p>Use <code>paginate()</code> to get structured pagination data:</p> <pre><code>$paginated = User::query()\n    -&gt;where('country', 'Brazil')\n    -&gt;orderBy('id')\n    -&gt;paginate(page: 2, perPage: 5);\n\nprint_r($paginated);\n</code></pre> <p>Output:</p> <pre><code>[\n    'data' =&gt; [ ... array of User models ... ],\n    'total' =&gt; 43,\n    'per_page' =&gt; 5,\n    'current_page' =&gt; 2,\n    'last_page' =&gt; 9\n]\n</code></pre> <p>Pagination automatically uses <code>COUNT(*)</code> internally.</p>"},{"location":"queries/#updating-records","title":"\u270f\ufe0f Updating Records","text":"<p>Perform updates directly via the builder:</p> <pre><code>User::query()\n    -&gt;where('country', 'Brazil')\n    -&gt;update(['active' =&gt; false]);\n</code></pre> <p>Returns <code>true</code> if successful, or throws an exception on error.</p> <p>Or use the model API instead:</p> <pre><code>$user = User::find(1);\n$user-&gt;name = 'Updated';\n$user-&gt;save();\n</code></pre>"},{"location":"queries/#deleting-records","title":"\ud83d\uddd1\ufe0f Deleting Records","text":"<p>Delete records via the builder:</p> <pre><code>User::query()\n    -&gt;where('id', 10)\n    -&gt;delete();\n</code></pre> <p>Or delete via the model API:</p> <pre><code>$user = User::find(10);\n$user-&gt;delete();\n</code></pre>"},{"location":"queries/#counting-records","title":"\ud83e\uddea Counting Records","text":"<p>Count results matching your filters:</p> <pre><code>$total = User::query()\n    -&gt;where('active', true)\n    -&gt;count();\n\necho \"Active users: {$total}\";\n</code></pre>"},{"location":"queries/#building-sql-strings","title":"\u2699\ufe0f Building SQL Strings","text":"<p>You can inspect the raw SQL generated by the builder:</p> <pre><code>$sql = User::query()\n    -&gt;where('id', '&gt;', 10)\n    -&gt;orderBy('name')\n    -&gt;getSql();\n\necho $sql;\n</code></pre> <p>Example output:</p> <pre><code>SELECT users.id, users.name, users.email FROM users WHERE id &gt; :id_0 ORDER BY name ASC\n</code></pre> <p>Rubik safely binds parameters, but you can preview SQL to debug complex queries.</p>"},{"location":"queries/#model-hydration","title":"\ud83e\udde9 Model Hydration","text":"<p>When using a model-bound query (<code>User::query()</code>), Rubik hydrates each record into a model instance:</p> <pre><code>$users = User::query()-&gt;where('id', '&lt;', 5)-&gt;all();\n\nforeach ($users as $user) {\n    echo $user-&gt;name;\n}\n</code></pre> <p>Each hydrated model supports full ORM features:</p> <ul> <li><code>save()</code></li> <li><code>delete()</code></li> <li><code>toArray()</code></li> <li>Relationships (<code>hasMany</code>, <code>belongsTo</code>, etc.)</li> </ul> <p>If you use the builder without a model:</p> <pre><code>use AdaiasMagdiel\\Rubik\\Query;\n\n$results = (new Query())-&gt;setTable('users')-&gt;all();\n</code></pre> <p>then results are returned as plain associative arrays instead.</p>"},{"location":"queries/#executing-arbitrary-queries","title":"\ud83d\udcbe Executing Arbitrary Queries","text":"<p>You can run any SQL using Rubik\u2019s connection:</p> <pre><code>$conn = AdaiasMagdiel\\Rubik\\Rubik::getConn();\n$stmt = $conn-&gt;query('SELECT COUNT(*) AS total FROM users');\n$total = $stmt-&gt;fetchColumn();\n</code></pre> <p>Rubik doesn\u2019t restrict direct SQL \u2014 the Query Builder is optional for convenience.</p>"},{"location":"queries/#error-handling","title":"\ud83e\udde0 Error Handling","text":"<p>Rubik throws <code>RuntimeException</code> or <code>InvalidArgumentException</code> on:</p> <ul> <li>Invalid SQL operations</li> <li>Missing table or driver</li> <li>Incorrect operators</li> <li>Invalid pagination parameters</li> </ul> <p>You can safely wrap builder calls in <code>try/catch</code> blocks:</p> <pre><code>try {\n    $users = User::query()-&gt;where('id', '&gt;', 10)-&gt;all();\n} catch (RuntimeException $e) {\n    echo \"Query failed: \" . $e-&gt;getMessage();\n}\n</code></pre>"},{"location":"queries/#summary-of-query-methods","title":"\ud83e\uddfe Summary of Query Methods","text":"Method Description <code>select($fields)</code> Specify columns to select <code>where($key, $operatorOrValue, $value = null)</code> Add a WHERE condition <code>orWhere($key, $operatorOrValue, $value = null)</code> Add an OR condition <code>whereIn($key, array $values)</code> Add a WHERE IN condition <code>join($table, $left, $op, $right)</code> Add an INNER JOIN <code>leftJoin($table, $left, $op, $right)</code> Add a LEFT JOIN <code>rightJoin($table, $left, $op, $right)</code> Add a RIGHT JOIN <code>orderBy($column, $direction)</code> Sort results <code>groupBy($column)</code> Group results <code>having($condition)</code> Filter aggregates <code>limit($n)</code> Limit results <code>offset($n)</code> Skip results <code>count()</code> Count total records <code>paginate($page, $perPage)</code> Paginate results <code>update($data)</code> Update records <code>delete()</code> Delete records <code>getSql()</code> Return raw SQL string <code>first()</code> Return first record <code>all()</code> Return all records"},{"location":"queries/#next-steps","title":"\ud83e\udded Next Steps","text":"<ul> <li>Models \u2014 Learn how models integrate with queries</li> <li>Relationships \u2014 Load related data elegantly</li> </ul>"},{"location":"relationships/","title":"Relationships","text":"<p>Rubik ORM supports defining relationships between models using a clean, declarative syntax. Relationships are lazy-loaded on demand \u2014 meaning they are only queried when first accessed \u2014 and then cached for reuse.</p> <p>Supported relationship types:</p> <ul> <li><code>belongsTo</code> \u2014 a model references another one (foreign key on current table)</li> <li><code>hasOne</code> \u2014 a model owns a single related record</li> <li><code>hasMany</code> \u2014 a model owns multiple related records</li> <li><code>belongsToMany</code> \u2014 many-to-many relationship through a pivot table</li> </ul>"},{"location":"relationships/#defining-relationships","title":"\u2699\ufe0f Defining Relationships","text":"<p>Each model can define its relationships by overriding the static <code>relationships()</code> method:</p> <pre><code>use App\\Models\\User;\nuse App\\Models\\Post;\n\nclass Post extends Model\n{\n    protected static string $table = 'posts';\n\n    protected static function fields(): array\n    {\n        return [\n            'id' =&gt; Column::Integer(primaryKey: true, autoincrement: true),\n            'user_id' =&gt; Column::Integer(\n                notNull: true,\n                foreignKey: Column::ForeignKey('id', 'users', 'CASCADE', 'CASCADE')\n            ),\n            'title' =&gt; Column::Varchar(length: 255, notNull: true),\n            'body' =&gt; Column::Text(),\n        ];\n    }\n\n    protected static function relationships(): array\n    {\n        return [\n            'author' =&gt; [\n                'type' =&gt; 'belongsTo',\n                'related' =&gt; User::class,\n                'foreignKey' =&gt; 'user_id',\n                'ownerKey' =&gt; 'id',\n            ],\n        ];\n    }\n}\n</code></pre> <p>\ud83d\udca1 Rubik automatically infers most keys when you follow naming conventions (<code>user_id</code>, <code>post_id</code>, etc.), but you can override them explicitly.</p>"},{"location":"relationships/#belongsto","title":"\ud83d\udd01 belongsTo","text":"<p>Defines a reverse one-to-one or many-to-one relationship (current model has a foreign key pointing to another model).</p> <pre><code>$post = Post::find(1);\n$user = $post-&gt;author; // Lazy-loaded User instance\n</code></pre>"},{"location":"relationships/#sql-generated","title":"SQL generated","text":"<pre><code>SELECT * FROM users WHERE id = :user_id LIMIT 1;\n</code></pre>"},{"location":"relationships/#example","title":"Example","text":"<pre><code>class User extends Model\n{\n    protected static string $table = 'users';\n}\n\nclass Post extends Model\n{\n    protected static string $table = 'posts';\n\n    protected static function relationships(): array\n    {\n        return [\n            'author' =&gt; [\n                'type' =&gt; 'belongsTo',\n                'related' =&gt; User::class,\n                'foreignKey' =&gt; 'user_id',\n            ],\n        ];\n    }\n}\n</code></pre>"},{"location":"relationships/#hasone","title":"\ud83e\udde9 hasOne","text":"<p>Defines a one-to-one relationship (the current model owns exactly one related record).</p> <pre><code>$user = User::find(1);\n$profile = $user-&gt;profile;\n</code></pre>"},{"location":"relationships/#sql-generated_1","title":"SQL generated","text":"<pre><code>SELECT * FROM profiles WHERE user_id = :user_id LIMIT 1;\n</code></pre>"},{"location":"relationships/#example_1","title":"Example","text":"<pre><code>class Profile extends Model\n{\n    protected static string $table = 'profiles';\n}\n\nclass User extends Model\n{\n    protected static string $table = 'users';\n\n    protected static function relationships(): array\n    {\n        return [\n            'profile' =&gt; [\n                'type' =&gt; 'hasOne',\n                'related' =&gt; Profile::class,\n                'foreignKey' =&gt; 'user_id',\n                'localKey' =&gt; 'id',\n            ],\n        ];\n    }\n}\n</code></pre>"},{"location":"relationships/#hasmany","title":"\ud83e\uddee hasMany","text":"<p>Defines a one-to-many relationship (the current model has multiple related records).</p> <pre><code>$user = User::find(1);\n$posts = $user-&gt;posts;\n</code></pre>"},{"location":"relationships/#sql-generated_2","title":"SQL generated","text":"<pre><code>SELECT * FROM posts WHERE user_id = :id;\n</code></pre>"},{"location":"relationships/#example_2","title":"Example","text":"<pre><code>class User extends Model\n{\n    protected static string $table = 'users';\n\n    protected static function relationships(): array\n    {\n        return [\n            'posts' =&gt; [\n                'type' =&gt; 'hasMany',\n                'related' =&gt; Post::class,\n                'foreignKey' =&gt; 'user_id',\n                'localKey' =&gt; 'id',\n            ],\n        ];\n    }\n}\n</code></pre> <p>\u26a1 The result of a <code>hasMany</code> relationship is always an array of models.</p>"},{"location":"relationships/#belongstomany","title":"\ud83d\udd17 belongsToMany","text":"<p>Defines a many-to-many relationship using a pivot table.</p> <pre><code>$post = Post::find(1);\n$tags = $post-&gt;tags;\n</code></pre>"},{"location":"relationships/#sql-generated_3","title":"SQL generated","text":"<pre><code>SELECT tags.*\nFROM tags\nINNER JOIN post_tag ON post_tag.tag_id = tags.id\nWHERE post_tag.post_id = :post_id;\n</code></pre>"},{"location":"relationships/#example_3","title":"Example","text":"<pre><code>class Tag extends Model\n{\n    protected static string $table = 'tags';\n}\n\nclass Post extends Model\n{\n    protected static string $table = 'posts';\n\n    protected static function relationships(): array\n    {\n        return [\n            'tags' =&gt; [\n                'type' =&gt; 'belongsToMany',\n                'related' =&gt; Tag::class,\n                'pivotTable' =&gt; 'post_tag',\n                'foreignKey' =&gt; 'post_id',\n                'relatedKey' =&gt; 'tag_id',\n                'localKey' =&gt; 'id',\n                'relatedOwnerKey' =&gt; 'id',\n            ],\n        ];\n    }\n}\n</code></pre>"},{"location":"relationships/#lazy-loading-and-caching","title":"\ud83e\udde0 Lazy Loading and Caching","text":"<p>When you access a relationship property (like <code>$user-&gt;posts</code>), Rubik executes the relationship query only once per model instance.</p> <p>Subsequent accesses reuse the cached results:</p> <pre><code>$user = User::find(1);\n\n// Executes one query\n$posts = $user-&gt;posts;\n\n// Uses cached data (no new query)\n$postsAgain = $user-&gt;posts;\n</code></pre> <p>This improves performance without requiring eager loading.</p>"},{"location":"relationships/#combining-with-query-builder","title":"\ud83d\ude80 Combining with Query Builder","text":"<p>Relationships return Query instances under the hood. You can modify them like any other builder before executing:</p> <pre><code>$user = User::find(1);\n\n// Filter related posts\n$recentPosts = $user-&gt;hasMany(Post::class, 'user_id')\n    -&gt;where('created_at', '&gt;=', '2025-01-01')\n    -&gt;orderBy('id', 'DESC')\n    -&gt;limit(5)\n    -&gt;all();\n</code></pre> <p>Or start from a defined relationship key:</p> <pre><code>$recentPosts = $user-&gt;posts\n    ? array_filter($user-&gt;posts, fn($p) =&gt; $p-&gt;active)\n    : [];\n</code></pre>"},{"location":"relationships/#summary-of-relationship-types","title":"\ud83e\udde9 Summary of Relationship Types","text":"Type Direction Example Returns <code>belongsTo</code> Reverse <code>$post-&gt;author</code> Single model <code>hasOne</code> Forward <code>$user-&gt;profile</code> Single model <code>hasMany</code> Forward <code>$user-&gt;posts</code> Array of models <code>belongsToMany</code> Many-Many <code>$post-&gt;tags</code> Array of models"},{"location":"relationships/#next-steps","title":"\ud83e\udded Next Steps","text":"<ul> <li>Models \u2014 Define your models and fields</li> <li>Query Builder \u2014 Learn how to query related data</li> </ul>"},{"location":"sql-raw/","title":"SQL Raw Expressions","text":"<p>The <code>AdaiasMagdiel\\Rubik\\SQL</code> class is a value object representing a literal SQL fragment that must be inserted into generated SQL verbatim, without quoting or binding.</p> <p>This is useful when you need to use SQL functions, constants, or expressions such as <code>CURRENT_TIMESTAMP</code>, <code>NOW()</code>, <code>gen_random_uuid()</code>, or similar \u2014 anywhere Rubik would otherwise escape or bind a value.</p>"},{"location":"sql-raw/#importing","title":"\ud83e\udde9 Importing","text":"<pre><code>use AdaiasMagdiel\\Rubik\\SQL;\n</code></pre>"},{"location":"sql-raw/#purpose","title":"\u2699\ufe0f Purpose","text":"<p><code>SQL::raw()</code> lets you embed literal SQL fragments in:</p> <ul> <li>Column definitions (e.g., <code>DEFAULT CURRENT_TIMESTAMP</code>)</li> <li>Update queries</li> <li>Where conditions</li> <li>Schema constraints</li> </ul> <p>Everywhere else, Rubik escapes and binds values normally \u2014 this object simply signals \"do not quote this value\".</p>"},{"location":"sql-raw/#in-column-definitions","title":"\ud83e\uddf1 In Column Definitions","text":"<p>The <code>Column</code> builder fully supports <code>SQL::raw()</code> for literal defaults or <code>onUpdate</code> clauses.</p> <p>Example:</p> <pre><code>use AdaiasMagdiel\\Rubik\\Column;\nuse AdaiasMagdiel\\Rubik\\SQL;\n\nclass User extends Model\n{\n    protected static string $table = 'users';\n\n    protected static function fields(): array\n    {\n        return [\n            'id' =&gt; Column::Integer(primaryKey: true, autoincrement: true),\n            'name' =&gt; Column::Varchar(length: 100, notNull: true),\n            'email' =&gt; Column::Varchar(length: 150, notNull: true, unique: true),\n            'created_at' =&gt; Column::Datetime(default: SQL::raw('CURRENT_TIMESTAMP')),\n            'updated_at' =&gt; Column::Datetime(default: SQL::raw('CURRENT_TIMESTAMP')),\n        ];\n    }\n}\n</code></pre> <p>Generated SQL (SQLite):</p> <pre><code>CREATE TABLE users (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    name TEXT NOT NULL,\n    email TEXT NOT NULL UNIQUE,\n    created_at TEXT DEFAULT CURRENT_TIMESTAMP,\n    updated_at TEXT DEFAULT CURRENT_TIMESTAMP\n);\n</code></pre> <p>\u2705 All validators in <code>Column</code> accept <code>SQL::raw()</code> wherever literal defaults are allowed.</p>"},{"location":"sql-raw/#in-queries","title":"\ud83d\udd0d In Queries","text":"<p><code>SQL::raw()</code> can be used in queries through the <code>Query</code> builder.</p>"},{"location":"sql-raw/#example-computed-columns","title":"Example \u2014 computed columns","text":"<pre><code>$users = User::query()\n    -&gt;select([\n        'id',\n        'name',\n        SQL::raw('LENGTH(name) AS name_length'),\n    ])\n    -&gt;all();\n</code></pre> <p>Generated SQL:</p> <pre><code>SELECT id, name, LENGTH(name) AS name_length FROM users;\n</code></pre>"},{"location":"sql-raw/#example-where-conditions","title":"Example \u2014 WHERE conditions","text":"<pre><code>User::query()\n    -&gt;where(SQL::raw('DATE(created_at)'), '&gt;=', SQL::raw('DATE(\"2025-01-01\")'))\n    -&gt;all();\n</code></pre> <p>Generated SQL:</p> <pre><code>SELECT * FROM users WHERE DATE(created_at) &gt;= DATE(\"2025-01-01\");\n</code></pre>"},{"location":"sql-raw/#in-update-statements","title":"\u270f\ufe0f In Update Statements","text":"<p>You can safely use <code>SQL::raw()</code> when updating with expressions.</p> <pre><code>User::query()\n    -&gt;where('id', 1)\n    -&gt;update(['updated_at' =&gt; SQL::raw('CURRENT_TIMESTAMP')]);\n</code></pre> <p>Generated SQL:</p> <pre><code>UPDATE users SET updated_at = CURRENT_TIMESTAMP WHERE id = :id_0;\n</code></pre> <p>Rubik will detect the <code>SQL</code> object and inject the raw fragment directly instead of binding it.</p>"},{"location":"sql-raw/#in-model-save-and-update","title":"\ud83e\uddee In Model <code>save()</code> and <code>update()</code>","text":"<p>When you assign <code>SQL::raw()</code> to a model field and call <code>save()</code> or <code>update()</code>, Rubik also respects it:</p> <pre><code>$user = User::find(1);\n$user-&gt;updated_at = SQL::raw('CURRENT_TIMESTAMP');\n$user-&gt;save();\n</code></pre> <p>\u2192 The ORM will generate an <code>UPDATE</code> that includes <code>CURRENT_TIMESTAMP</code> verbatim.</p>"},{"location":"sql-raw/#how-it-works","title":"\ud83e\uddf0 How It Works","text":"<p>The <code>SQL</code> class is a simple immutable value object:</p> <pre><code>final class SQL\n{\n    private string $expr;\n\n    public function __construct(string $expr)\n    {\n        $this-&gt;expr = $expr;\n    }\n\n    public function __toString(): string\n    {\n        return $this-&gt;expr;\n    }\n\n    public static function raw(string $expr): static\n    {\n        return new static($expr);\n    }\n}\n</code></pre> <p>Internally, Rubik checks if a value is an instance of <code>AdaiasMagdiel\\Rubik\\SQL</code>. If it is, Rubik converts it to a string and skips parameter binding.</p> <p>Places that handle this:</p> <ul> <li><code>Column</code> validation methods (<code>validateDecimal</code>, <code>validateInteger</code>, etc.)</li> <li><code>SchemaTrait::escapeDefaultValue()</code></li> <li><code>Query::addCondition()</code> (WHERE clauses)</li> <li><code>Query::update()</code> (SET clauses)</li> </ul>"},{"location":"sql-raw/#security-warning","title":"\u26a0\ufe0f Security Warning","text":"<p><code>SQL::raw()</code> completely bypasses quoting and escaping. Never use it with user input or untrusted data.</p> <p>Safe examples \u2705:</p> <pre><code>SQL::raw('CURRENT_TIMESTAMP')\nSQL::raw('LENGTH(name)')\nSQL::raw('gen_random_uuid()')\n</code></pre> <p>Unsafe examples \ud83d\udeab:</p> <pre><code>SQL::raw(\"name = '{$_GET['name']}'\")  // \u274c Injection risk\nSQL::raw($_POST['query'])              // \u274c Dangerous\n</code></pre>"},{"location":"sql-raw/#summary","title":"\ud83e\udded Summary","text":"Context Example Behavior Column default <code>Column::Datetime(default: SQL::raw('CURRENT_TIMESTAMP'))</code> Default literal value Schema onUpdate <code>Column::Datetime(onUpdate: SQL::raw('CURRENT_TIMESTAMP'))</code> Literal ON UPDATE Query select <code>SQL::raw('LENGTH(name) AS len')</code> Computed column Query where <code>-&gt;where(SQL::raw('DATE(created_at)'), '&gt;=', SQL::raw('DATE(\"2025-01-01\")'))</code> Raw condition Query update <code>-&gt;update(['updated_at' =&gt; SQL::raw('CURRENT_TIMESTAMP')])</code> Unquoted expression Model save/update <code>$model-&gt;field = SQL::raw('NOW()')</code> Injects raw SQL value"},{"location":"reference/column/","title":"\ud83e\uddf1 Column","text":"<p>The <code>Column</code> class provides a driver-aware, type-safe way to define table columns in Rubik ORM. It adapts automatically to SQLite and MySQL, enforcing valid type attributes and constraints.</p> <p>You can define columns directly inside your model\u2019s static <code>fields()</code> method, or use it to build schema definitions programmatically.</p>"},{"location":"reference/column/#overview","title":"\u2699\ufe0f Overview","text":"<p>Rubik\u2019s <code>Column</code> builder:</p> <ul> <li>Supports over 40 SQL column types</li> <li>Applies driver-specific mappings (SQLite, MySQL, PostgreSQL-ready)</li> <li>Validates lengths, precision, defaults, and constraints</li> <li>Supports raw SQL expressions via <code>SQL::raw()</code></li> <li>Provides helper for defining foreign keys</li> </ul>"},{"location":"reference/column/#importing","title":"\ud83e\udde9 Importing","text":"<pre><code>use AdaiasMagdiel\\Rubik\\Column;\nuse AdaiasMagdiel\\Rubik\\SQL;\n</code></pre>"},{"location":"reference/column/#basic-usage","title":"\ud83e\uddf1 Basic Usage","text":"<p>Define your columns inside your model:</p> <pre><code>use AdaiasMagdiel\\Rubik\\Model;\nuse AdaiasMagdiel\\Rubik\\Column;\n\nclass User extends Model\n{\n    protected static string $table = 'users';\n\n    protected static function fields(): array\n    {\n        return [\n            'id' =&gt; Column::Integer(primaryKey: true, autoincrement: true),\n            'name' =&gt; Column::Varchar(length: 100, notNull: true),\n            'email' =&gt; Column::Varchar(length: 150, notNull: true, unique: true),\n            'active' =&gt; Column::Boolean(default: true),\n            'created_at' =&gt; Column::Datetime(default: SQL::raw('CURRENT_TIMESTAMP')),\n        ];\n    }\n}\n</code></pre>"},{"location":"reference/column/#supported-column-types","title":"\ud83e\uddee Supported Column Types","text":"<p>Rubik ORM supports a wide range of logical column types, automatically mapped to each supported driver (SQLite, MySQL, PostgreSQL-ready).</p> <p>All type conversions are handled internally according to the active driver.</p>"},{"location":"reference/column/#numeric-types","title":"\ud83d\udd22 Numeric Types","text":"Logical Type SQLite MySQL PostgreSQL <code>INTEGER</code> INTEGER INTEGER INTEGER <code>BIGINT</code> INTEGER BIGINT BIGINT <code>SMALLINT</code> INTEGER SMALLINT SMALLINT <code>TINYINT</code> INTEGER TINYINT SMALLINT <code>MEDIUMINT</code> INTEGER MEDIUMINT INTEGER <code>NUMERIC</code> NUMERIC NUMERIC NUMERIC <code>DECIMAL</code> NUMERIC DECIMAL DECIMAL <code>REAL</code> REAL DOUBLE DOUBLE PRECISION <code>FLOAT</code> REAL FLOAT DOUBLE PRECISION <code>DOUBLE</code> REAL DOUBLE DOUBLE PRECISION <code>BIT</code> INTEGER BIT(1) BIT(1)"},{"location":"reference/column/#serial-auto-increment-types","title":"\ud83d\udd01 Serial / Auto-increment Types","text":"Logical Type SQLite MySQL PostgreSQL <code>SERIAL</code> INTEGER INTEGER AUTO_INCREMENT SERIAL <code>BIGSERIAL</code> INTEGER BIGINT AUTO_INCREMENT BIGSERIAL <code>SMALLSERIAL</code> INTEGER SMALLINT AUTO_INCREMENT SMALLSERIAL <p>\ud83d\udca1 These are aliases that simplify creating auto-incrementing primary keys.</p>"},{"location":"reference/column/#textual-types","title":"\ud83d\udcdd Textual Types","text":"Logical Type SQLite MySQL PostgreSQL <code>TEXT</code> TEXT TEXT TEXT <code>VARCHAR</code> TEXT VARCHAR(255) VARCHAR <code>CHAR</code> TEXT CHAR(1) CHAR <code>TINYTEXT</code> TEXT TINYTEXT TEXT <code>MEDIUMTEXT</code> TEXT MEDIUMTEXT TEXT <code>LONGTEXT</code> TEXT LONGTEXT TEXT <code>JSON</code> TEXT JSON TEXT <code>JSONB</code> TEXT JSON JSONB <code>UUID</code> TEXT CHAR(36) UUID"},{"location":"reference/column/#boolean-enum-set","title":"\u2699\ufe0f Boolean / Enum / Set","text":"Logical Type SQLite MySQL PostgreSQL <code>BOOLEAN</code> INTEGER TINYINT(1) BOOLEAN <code>ENUM</code> TEXT ENUM('a','b',...) TEXT <code>SET</code> TEXT SET('a','b',...) TEXT"},{"location":"reference/column/#date-time-types","title":"\ud83d\udcc5 Date &amp; Time Types","text":"Logical Type SQLite MySQL PostgreSQL <code>DATE</code> TEXT DATE DATE <code>DATETIME</code> TEXT DATETIME TIMESTAMP <code>TIMESTAMP</code> TEXT TIMESTAMP TIMESTAMP <code>TIME</code> TEXT TIME TIME <code>YEAR</code> INTEGER YEAR INTEGER <p>\u23f0 Rubik normalizes precision and time zone handling automatically. For default values, you can safely use <code>SQL::raw('CURRENT_TIMESTAMP')</code>.</p>"},{"location":"reference/column/#binary-blob-types","title":"\ud83d\udcbe Binary / Blob Types","text":"Logical Type SQLite MySQL PostgreSQL <code>BLOB</code> BLOB BLOB BYTEA <code>TINYBLOB</code> BLOB TINYBLOB BYTEA <code>MEDIUMBLOB</code> BLOB MEDIUMBLOB BYTEA <code>LONGBLOB</code> BLOB LONGBLOB BYTEA <code>BYTEA</code> BLOB LONGBLOB BYTEA <code>BINARY</code> BLOB BINARY(1) BYTEA <code>VARBINARY</code> BLOB VARBINARY(255) BYTEA <p>\ud83e\udde9 All binary types are compatible with <code>BLOB</code> internally on SQLite.</p>"},{"location":"reference/column/#spatial-geometric-types","title":"\ud83e\udded Spatial / Geometric Types","text":"Logical Type SQLite MySQL PostgreSQL <code>GEOMETRY</code> BLOB GEOMETRY GEOMETRY <code>POINT</code> BLOB POINT POINT <code>LINESTRING</code> BLOB LINESTRING LINESTRING <code>POLYGON</code> BLOB POLYGON POLYGON <p>\ud83c\udf0d Spatial and geometric types are defined for forward-compatibility. They behave as binary columns in SQLite and as native geometry types in Postgres.</p>"},{"location":"reference/column/#notes","title":"\ud83e\udde9 Notes","text":"<ul> <li>All types are case-insensitive when invoked (<code>Column::integer()</code>, <code>Column::INTEGER()</code>, etc.).</li> <li>Validation rules (length, scale, defaults) are automatically enforced.</li> <li>If you use an unsupported type name, Rubik throws <code>BadMethodCallException</code>.</li> </ul> <p>Example:</p> <pre><code>class Location extends Model\n{\n    protected static string $table = 'locations';\n\n    protected static function fields(): array\n    {\n        return [\n            'id' =&gt; Column::BIGSERIAL(primaryKey: true),\n            'name' =&gt; Column::Varchar(length: 200, notNull: true),\n            'coordinates' =&gt; Column::POINT(),\n            'created_at' =&gt; Column::Datetime(default: SQL::raw('CURRENT_TIMESTAMP')),\n        ];\n    }\n}\n</code></pre> <p>\ud83d\udca1 Rubik ORM will automatically generate compatible SQL for the active driver, handling type mapping, constraints, and validation under the hood.</p>"},{"location":"reference/column/#column-options","title":"\u2699\ufe0f Column Options","text":"<p>Each column type can take specific named arguments:</p> Option Type Applies To Description <code>length</code> <code>int</code> CHAR, VARCHAR, BINARY Maximum length <code>precision</code> <code>int</code> DECIMAL, FLOAT, NUMERIC Total digits <code>scale</code> <code>int</code> DECIMAL, FLOAT, NUMERIC Decimal places <code>autoincrement</code> <code>bool</code> INTEGER types Enables auto increment <code>primaryKey</code> <code>bool</code> All Marks column as primary key <code>notNull</code> <code>bool</code> All Adds NOT NULL <code>unique</code> <code>bool</code> All Adds UNIQUE constraint <code>default</code> <code>mixed</code> All Default value or <code>SQL::raw()</code> <code>unsigned</code> <code>bool</code> TINYINT, INT, FLOAT MySQL-only unsigned modifier <code>values</code> <code>array</code> ENUM, SET List of allowed values <code>foreignKey</code> <code>array</code> Any Defines FK (see below)"},{"location":"reference/column/#example-with-foreign-key","title":"\ud83e\uddfe Example \u2014 With Foreign Key","text":"<pre><code>use AdaiasMagdiel\\Rubik\\Column;\n\nclass Post extends Model\n{\n    protected static string $table = 'posts';\n\n    protected static function fields(): array\n    {\n        return [\n            'id' =&gt; Column::Integer(primaryKey: true, autoincrement: true),\n            'user_id' =&gt; Column::Integer(\n                notNull: true,\n                foreignKey: Column::ForeignKey('id', 'users', 'CASCADE', 'NO ACTION')\n            ),\n            'title' =&gt; Column::Varchar(length: 200, notNull: true),\n            'content' =&gt; Column::Text(),\n        ];\n    }\n}\n</code></pre> <p>Generated SQL (SQLite):</p> <pre><code>CREATE TABLE posts (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    user_id INTEGER NOT NULL,\n    title TEXT NOT NULL,\n    content TEXT,\n    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE\n);\n</code></pre>"},{"location":"reference/column/#foreign-key-helper","title":"\ud83d\udd17 Foreign Key Helper","text":""},{"location":"reference/column/#columnforeignkey","title":"<code>Column::ForeignKey()</code>","text":"<pre><code>Column::ForeignKey(\n    string $references,\n    string $table,\n    string $onDelete = 'NO ACTION',\n    string $onUpdate = 'NO ACTION'\n): array\n</code></pre> <p>Defines a normalized FK structure to merge into a column definition.</p> Parameter Description <code>references</code> Column name on the referenced table <code>table</code> Target table name <code>onDelete</code> Action on delete (CASCADE, SET NULL, etc.) <code>onUpdate</code> Action on update <p>Example:</p> <pre><code>'user_id' =&gt; Column::Integer(\n    notNull: true,\n    foreignKey: Column::ForeignKey('id', 'users', 'CASCADE', 'NO ACTION')\n)\n</code></pre>"},{"location":"reference/column/#sqlraw-integration","title":"\ud83e\uddf0 SQL::raw() Integration","text":"<p>Any default or update value can be a raw SQL literal:</p> <pre><code>'created_at' =&gt; Column::Datetime(default: SQL::raw('CURRENT_TIMESTAMP')),\n'updated_at' =&gt; Column::Datetime(onUpdate: SQL::raw('CURRENT_TIMESTAMP')),\n</code></pre> <p>Rubik detects <code>SQL::raw()</code> automatically and does not quote or bind it.</p>"},{"location":"reference/column/#validation-rules","title":"\ud83e\uddea Validation Rules","text":"<p>Rubik applies type-specific validation when building columns:</p> Validator Ensures <code>validateStringLength</code> CHAR/VARCHAR length between 1\u201365535 <code>validateDecimal</code> DECIMAL precision &amp; scale <code>validateInteger</code> INTEGER default is numeric <code>validateBoolean</code> Default is <code>true</code>, <code>false</code>, <code>0</code>, <code>1</code>, or <code>SQL::raw()</code> <code>validateEnum</code> ENUM has valid values and default <code>validateJson</code> Default is valid JSON or <code>SQL::raw()</code> <code>validateUuid</code> Default matches RFC 4122 <code>validateDateTime</code> DATETIME/TIMESTAMP precision 0\u20136 <code>validateSet</code> SET default matches allowed values <p>\ud83d\udca1 Validation happens at definition time, so you\u2019ll catch schema errors before running migrations.</p>"},{"location":"reference/column/#example-complete-schema","title":"\ud83e\uddee Example \u2014 Complete Schema","text":"<pre><code>class Product extends Model\n{\n    protected static string $table = 'products';\n\n    protected static function fields(): array\n    {\n        return [\n            'id' =&gt; Column::Integer(primaryKey: true, autoincrement: true),\n            'name' =&gt; Column::Varchar(length: 120, notNull: true, unique: true),\n            'price' =&gt; Column::Decimal(precision: 10, scale: 2, default: 0),\n            'available' =&gt; Column::Boolean(default: true),\n            'created_at' =&gt; Column::Datetime(default: SQL::raw('CURRENT_TIMESTAMP')),\n        ];\n    }\n}\n</code></pre>"},{"location":"reference/column/#output-example","title":"\u2699\ufe0f Output Example","text":"<pre><code>CREATE TABLE products (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    name TEXT NOT NULL UNIQUE,\n    price NUMERIC DEFAULT 0,\n    available INTEGER DEFAULT 1,\n    created_at TEXT DEFAULT CURRENT_TIMESTAMP\n);\n</code></pre>"},{"location":"reference/column/#notes_1","title":"\u26a0\ufe0f Notes","text":"<ul> <li>Always call <code>Rubik::connect()</code> before defining columns.</li> <li>Column definitions are driver-aware and validated immediately.</li> <li>Use <code>SQL::raw()</code> only for trusted, constant expressions.</li> </ul>"},{"location":"reference/column/#related","title":"\ud83d\udcd8 Related","text":"<ul> <li>Rubik Connection \u2014 Database configuration and DSN setup</li> <li>Model \u2014 Integrating column definitions into ORM models</li> <li>SQL \u2014 Embed literal SQL expressions safely</li> </ul>"},{"location":"reference/model/","title":"Model \u2014 API Reference","text":"<p>Namespace: <code>AdaiasMagdiel\\Rubik</code> Base class for all ORM models. Implements persistence, querying, schema definition, and serialization.</p>"},{"location":"reference/model/#class-definition","title":"Class Definition","text":"<pre><code>abstract class Model implements JsonSerializable\n</code></pre>"},{"location":"reference/model/#traits-used","title":"Traits Used","text":"Trait Namespace Responsibility <code>CrudTrait</code> <code>AdaiasMagdiel\\Rubik\\Trait\\Model\\CrudTrait</code> Insert / update / delete operations <code>QueryTrait</code> <code>AdaiasMagdiel\\Rubik\\Trait\\Model\\QueryTrait</code> Query builder and relationships <code>SchemaTrait</code> <code>AdaiasMagdiel\\Rubik\\Trait\\Model\\SchemaTrait</code> Field definition and schema management <code>SerializationTrait</code> <code>AdaiasMagdiel\\Rubik\\Trait\\Model\\SerializationTrait</code> Serialization to array / JSON"},{"location":"reference/model/#static-properties","title":"Static Properties","text":"Name Type Description <code>$table</code> <code>string</code> Table name for the model. Optional \u2014 inferred from class name if unset."},{"location":"reference/model/#instance-properties","title":"Instance Properties","text":"Name Type Description <code>$_data</code> <code>array&lt;string,mixed&gt;</code> Field values for the model. <code>$_dirty</code> <code>array&lt;string,bool&gt;</code> Tracks modified fields. <code>$_relationships</code> <code>array&lt;string,mixed&gt;</code> Cached relationship data."},{"location":"reference/model/#static-methods","title":"Static Methods","text":""},{"location":"reference/model/#protected-static-function-fields-array","title":"<code>protected static function fields(): array</code>","text":"<p>Defines the model\u2019s table fields. Must be implemented in subclasses.</p>"},{"location":"reference/model/#public-static-function-primarykey-string","title":"<code>public static function primaryKey(): string</code>","text":"<p>Returns the column name marked as <code>primary_key</code>.</p> <p>Throws <code>RuntimeException</code> if no primary key is defined.</p>"},{"location":"reference/model/#public-static-function-gettablename-string","title":"<code>public static function getTableName(): string</code>","text":"<p>Returns the effective table name:</p> <ul> <li><code>$table</code> property if defined</li> <li>or pluralized lowercase class name otherwise.</li> </ul>"},{"location":"reference/model/#public-static-function-query-query","title":"<code>public static function query(): Query</code>","text":"<p>Returns a new <code>Query</code> builder instance bound to the model.</p>"},{"location":"reference/model/#public-static-function-findmixed-id-static","title":"<code>public static function find(mixed $id): ?static</code>","text":"<p>Finds a model by primary key. Returns <code>null</code> if not found.</p>"},{"location":"reference/model/#public-static-function-first-static","title":"<code>public static function first(): ?static</code>","text":"<p>Returns the first record.</p>"},{"location":"reference/model/#public-static-function-all-arraystatic","title":"<code>public static function all(): array&lt;static&gt;</code>","text":"<p>Returns all records from the table.</p>"},{"location":"reference/model/#public-static-function-paginateint-page-int-perpage-array","title":"<code>public static function paginate(int $page, int $perPage): array</code>","text":"<p>Performs paginated query.</p> <p>Return format:</p> <pre><code>[\n  'data' =&gt; array&lt;static&gt;,\n  'total' =&gt; int,\n  'per_page' =&gt; int,\n  'current_page' =&gt; int,\n  'last_page' =&gt; int\n]\n</code></pre>"},{"location":"reference/model/#public-static-function-insertmanyarray-records-bool","title":"<code>public static function insertMany(array $records): bool</code>","text":"<p>Bulk insert operation.</p> <ul> <li>Executes all inserts inside a transaction.</li> <li>Rolls back on failure.</li> <li>Returns <code>true</code> if successful.</li> </ul>"},{"location":"reference/model/#public-static-function-createtablebool-ifnotexists-false-bool","title":"<code>public static function createTable(bool $ifNotExists = false): bool</code>","text":"<p>Creates the model\u2019s table using the definition from <code>fields()</code>.</p>"},{"location":"reference/model/#public-static-function-truncatetable-bool","title":"<code>public static function truncateTable(): bool</code>","text":"<p>Removes all records while keeping the table structure.</p>"},{"location":"reference/model/#public-static-function-droptablebool-ifexists-false-bool","title":"<code>public static function dropTable(bool $ifExists = false): bool</code>","text":"<p>Drops the table from the database.</p>"},{"location":"reference/model/#instance-methods","title":"Instance Methods","text":""},{"location":"reference/model/#public-function-__setstring-name-mixed-value-void","title":"<code>public function __set(string $name, mixed $value): void</code>","text":"<p>Assigns a field value and marks it dirty if the field exists in <code>fields()</code>.</p>"},{"location":"reference/model/#public-function-__getstring-key-mixed","title":"<code>public function __get(string $key): mixed</code>","text":"<p>Retrieves:</p> <ul> <li>A field value from <code>_data</code>, or</li> <li>A relationship result from <code>_relationships</code>.</li> </ul> <p>Automatically resolves relationships defined in <code>relationships()</code>.</p>"},{"location":"reference/model/#protected-static-function-relationships-array","title":"<code>protected static function relationships(): array</code>","text":"<p>Defines model relationships. Expected format:</p> <pre><code>[\n  'relationName' =&gt; [\n    'type' =&gt; 'belongsTo' | 'hasOne' | 'hasMany' | 'belongsToMany',\n    'related' =&gt; RelatedModel::class,\n    'foreignKey' =&gt; 'column',\n    'ownerKey' =&gt; 'id',\n    'pivotTable' =&gt; 'pivot_table_name' // for belongsToMany only\n  ],\n]\n</code></pre>"},{"location":"reference/model/#public-function-savebool-ignore-false-bool","title":"<code>public function save(bool $ignore = false): bool</code>","text":"<p>Inserts or updates the current record.</p> <ul> <li>Performs INSERT if PK not set.</li> <li>Performs UPDATE if PK exists.</li> <li><code>$ignore = true</code> \u2192 uses <code>INSERT OR IGNORE</code> (SQLite only).</li> </ul>"},{"location":"reference/model/#public-function-update-bool","title":"<code>public function update(): bool</code>","text":"<p>Updates dirty fields in the database. Throws if primary key is missing.</p>"},{"location":"reference/model/#public-function-delete-bool","title":"<code>public function delete(): bool</code>","text":"<p>Deletes the current record. Throws if primary key is missing.</p>"},{"location":"reference/model/#public-function-toarray-array","title":"<code>public function toArray(): array</code>","text":"<p>Returns internal data (<code>$_data</code>) as an associative array.</p>"},{"location":"reference/model/#public-function-jsonserialize-array","title":"<code>public function jsonSerialize(): array</code>","text":"<p>Implements <code>JsonSerializable</code>. Equivalent to <code>toArray()</code>.</p>"},{"location":"reference/model/#relationship-helpers","title":"Relationship Helpers","text":"Method Signature Description <code>belongsTo</code> <code>(string $related, string $foreignKey, string $ownerKey = 'id'): Query</code> Defines inverse (many\u2192one) relation <code>hasOne</code> <code>(string $related, string $foreignKey, string $localKey = 'id'): Query</code> Defines one-to-one relation <code>hasMany</code> <code>(string $related, string $foreignKey, string $localKey = 'id'): Query</code> Defines one-to-many relation <code>belongsToMany</code> <code>(string $related, string $pivotTable, string $foreignKey, string $relatedKey, string $localKey = 'id', string $relatedOwnerKey = 'id'): Query</code> Defines many-to-many relation via pivot table"},{"location":"reference/model/#exceptions","title":"Exceptions","text":"Exception Condition <code>RuntimeException</code> When required configuration (connection, PK, etc.) is missing <code>InvalidArgumentException</code> When invalid arguments or relationships are provided"},{"location":"reference/model/#related-classes","title":"Related Classes","text":"Class Description <code>Query</code> Query builder returned by <code>query()</code>. <code>Column</code> Column definition builder used in <code>fields()</code>. <code>SQL</code> Raw SQL expression wrapper for literal defaults."},{"location":"reference/query/","title":"Query \u2014 API Reference","text":"<p>Namespace: <code>AdaiasMagdiel\\Rubik</code> Provides a fluent query builder for Rubik ORM models. Supports <code>SELECT</code>, <code>UPDATE</code>, <code>DELETE</code>, filtering, joins, grouping, ordering, and pagination.</p>"},{"location":"reference/query/#class-definition","title":"Class Definition","text":"<pre><code>class Query\n</code></pre>"},{"location":"reference/query/#properties","title":"Properties","text":"Name Type Description <code>$model</code> <code>string</code> Fully qualified class name of the model being queried. <code>$table</code> <code>string</code> Table name of the query. <code>$operation</code> <code>string</code> SQL operation type (<code>SELECT</code>, <code>UPDATE</code>, <code>DELETE</code>). <code>$select</code> <code>array&lt;int,string&gt;</code> Columns to select. <code>$where</code> <code>array&lt;int,string&gt;</code> WHERE conditions. <code>$bindings</code> <code>array&lt;string,mixed&gt;</code> Bound parameters for prepared statements. <code>$orderBy</code> <code>array&lt;int,string&gt;</code> ORDER BY clauses. <code>$groupBy</code> <code>array&lt;int,string&gt;</code> GROUP BY columns. <code>$having</code> <code>array&lt;int,string&gt;</code> HAVING conditions. <code>$joins</code> <code>array&lt;int,string&gt;</code> JOIN clauses. <code>$limit</code> <code>int</code> LIMIT value (default -1 = none). <code>$offset</code> <code>int</code> OFFSET value (default -1 = none)."},{"location":"reference/query/#methods","title":"Methods","text":""},{"location":"reference/query/#public-function-settablestring-table-self","title":"<code>public function setTable(string $table): self</code>","text":"<p>Sets the target table name. Returns the query instance for chaining.</p>"},{"location":"reference/query/#public-function-setmodelstring-model-self","title":"<code>public function setModel(string $model): self</code>","text":"<p>Associates a model class with the query. Automatically sets <code>$table</code> using <code>Model::getTableName()</code>.</p> <p>Throws <code>RuntimeException</code> if the class does not exist.</p>"},{"location":"reference/query/#public-function-selectstringarray-fields-self","title":"<code>public function select(string|array $fields = '*'): self</code>","text":"<p>Defines columns to select.</p> <ul> <li>Accepts string or array.</li> <li>Automatically includes the model\u2019s primary key.</li> <li>Preserves <code>AS</code> aliases.</li> </ul>"},{"location":"reference/query/#public-function-wherestring-key-mixed-operatororvalue-mixed-value-null-self","title":"<code>public function where(string $key, mixed $operatorOrValue, mixed $value = null): self</code>","text":"<p>Adds a <code>WHERE</code> condition joined by <code>AND</code>.</p> <p>Equivalent to:</p> <pre><code>WHERE key = value\n</code></pre> <p>or</p> <pre><code>WHERE key operator value\n</code></pre>"},{"location":"reference/query/#public-function-orwherestring-key-mixed-operatororvalue-mixed-value-null-self","title":"<code>public function orWhere(string $key, mixed $operatorOrValue, mixed $value = null): self</code>","text":"<p>Adds a <code>WHERE</code> condition joined by <code>OR</code>.</p>"},{"location":"reference/query/#public-function-whereinstring-key-array-values-self","title":"<code>public function whereIn(string $key, array $values): self</code>","text":"<p>Adds a <code>WHERE ... IN (...)</code> clause. Throws <code>InvalidArgumentException</code> if the array is empty.</p>"},{"location":"reference/query/#public-function-joinstring-table-string-left-string-op-string-right-self","title":"<code>public function join(string $table, string $left, string $op, string $right): self</code>","text":"<p>Adds an <code>INNER JOIN</code> clause.</p>"},{"location":"reference/query/#public-function-leftjoinstring-table-string-left-string-op-string-right-self","title":"<code>public function leftJoin(string $table, string $left, string $op, string $right): self</code>","text":"<p>Adds a <code>LEFT JOIN</code> clause.</p>"},{"location":"reference/query/#public-function-rightjoinstring-table-string-left-string-op-string-right-self","title":"<code>public function rightJoin(string $table, string $left, string $op, string $right): self</code>","text":"<p>Adds a <code>RIGHT JOIN</code> clause.</p>"},{"location":"reference/query/#public-function-orderbystring-column-string-direction-asc-self","title":"<code>public function orderBy(string $column, string $direction = 'ASC'): self</code>","text":"<p>Adds an <code>ORDER BY</code> clause. <code>$direction</code> must be <code>ASC</code> or <code>DESC</code>.</p>"},{"location":"reference/query/#public-function-groupbystring-column-self","title":"<code>public function groupBy(string $column): self</code>","text":"<p>Adds a <code>GROUP BY</code> clause.</p>"},{"location":"reference/query/#public-function-havingstring-condition-self","title":"<code>public function having(string $condition): self</code>","text":"<p>Adds a <code>HAVING</code> clause condition.</p>"},{"location":"reference/query/#public-function-limitint-limit-self","title":"<code>public function limit(int $limit): self</code>","text":"<p>Sets the <code>LIMIT</code> clause. Throws <code>InvalidArgumentException</code> if negative.</p>"},{"location":"reference/query/#public-function-offsetint-offset-self","title":"<code>public function offset(int $offset): self</code>","text":"<p>Sets the <code>OFFSET</code> clause. Throws <code>InvalidArgumentException</code> if negative.</p>"},{"location":"reference/query/#public-function-delete-bool","title":"<code>public function delete(): bool</code>","text":"<p>Executes a <code>DELETE FROM ...</code> query.</p> <p>Throws <code>RuntimeException</code> if statement preparation fails.</p>"},{"location":"reference/query/#public-function-updatearray-data-bool","title":"<code>public function update(array $data): bool</code>","text":"<p>Executes an <code>UPDATE ... SET ...</code> query.</p> <ul> <li>Automatically binds parameters.</li> <li>Accepts <code>SQL::raw()</code> values (inserted verbatim).</li> <li>Returns <code>true</code> on success.</li> </ul>"},{"location":"reference/query/#public-function-paginateint-page-int-perpage-array","title":"<code>public function paginate(int $page, int $perPage): array</code>","text":"<p>Executes paginated query and returns a pagination array:</p> <pre><code>[\n  'data' =&gt; array&lt;object&gt;,\n  'total' =&gt; int,\n  'per_page' =&gt; int,\n  'current_page' =&gt; int,\n  'last_page' =&gt; int,\n]\n</code></pre> <p>Throws <code>InvalidArgumentException</code> if <code>$page</code> or <code>$perPage</code> &lt; 1.</p>"},{"location":"reference/query/#public-function-count-int","title":"<code>public function count(): int</code>","text":"<p>Counts total matching records. Internally issues a <code>SELECT COUNT(*)</code> query.</p>"},{"location":"reference/query/#public-function-all-array","title":"<code>public function all(): array</code>","text":"<p>Executes the query and returns all results. Results are hydrated into model instances if <code>$model</code> is set.</p>"},{"location":"reference/query/#public-function-first-object","title":"<code>public function first(): ?object</code>","text":"<p>Executes the query and returns the first result (or <code>null</code> if none). Automatically sets <code>LIMIT 1</code>.</p>"},{"location":"reference/query/#public-function-exec-bool","title":"<code>public function exec(): bool</code>","text":"<p>Executes the built query and returns <code>true</code> if any rows were affected.</p>"},{"location":"reference/query/#public-function-getsql-string","title":"<code>public function getSql(): string</code>","text":"<p>Returns the raw SQL string built by the query.</p> <p>Throws <code>RuntimeException</code> if:</p> <ul> <li>table not set, or</li> <li>attempting to get SQL for an <code>UPDATE</code> operation directly.</li> </ul>"},{"location":"reference/query/#protected-internal-methods","title":"Protected / Internal Methods","text":"Method Description <code>private function executeStatement(): PDOStatement</code> Prepares and executes the SQL with bound parameters. <code>private function addCondition(string $key, mixed $value, string $op, string $conjunction): void</code> Adds a condition to the <code>WHERE</code> clause. Supports <code>SQL::raw</code>. <code>private function buildJoinsClause(): string</code> Builds the <code>JOIN</code> section. <code>private function buildWhereClause(): string</code> Builds the <code>WHERE</code> section. <code>private function buildGroupByClause(): string</code> Builds the <code>GROUP BY</code> section. <code>private function buildHavingClause(): string</code> Builds the <code>HAVING</code> section. <code>private function buildOrderByClause(): string</code> Builds the <code>ORDER BY</code> section. <code>private function buildLimitClause(): string</code> Builds the <code>LIMIT</code> clause. <code>private function buildOffsetClause(): string</code> Builds the <code>OFFSET</code> clause. <code>private function hydrateModels(array $results): array</code> Hydrates array results into model instances. <code>private function hydrateModel(array $data): object</code> Instantiates and populates a model from result data."},{"location":"reference/query/#exceptions","title":"Exceptions","text":"Exception Condition <code>RuntimeException</code> Missing table, failed statement, or invalid operation. <code>InvalidArgumentException</code> Invalid parameters, operators, or pagination."},{"location":"reference/query/#related-classes","title":"Related Classes","text":"Class Description <code>Model</code> Provides the base model and relationship methods. <code>SQL</code> Wraps literal SQL fragments for safe injection."},{"location":"reference/rubik/","title":"\ud83e\udde9 Rubik ORM Core","text":"<p>The <code>Rubik</code> class is the central connection manager of the ORM. It handles all PDO connections, driver setup, and configuration for SQLite and MySQL.</p>"},{"location":"reference/rubik/#overview","title":"\u2699\ufe0f Overview","text":"<p>Rubik acts as a static gateway between your PHP application and the database. It maintains a single PDO connection instance and exposes utilities for:</p> <ul> <li>Connecting and disconnecting from the database</li> <li>Detecting which driver is active (<code>MySQL</code> or <code>SQLite</code>)</li> <li>Accessing the PDO instance directly when needed</li> <li>Managing driver-specific behavior (e.g. <code>PRAGMA foreign_keys</code> for SQLite)</li> </ul>"},{"location":"reference/rubik/#importing","title":"\ud83e\uddf1 Importing","text":"<pre><code>use AdaiasMagdiel\\Rubik\\Rubik;\nuse AdaiasMagdiel\\Rubik\\Enum\\Driver;\n</code></pre>"},{"location":"reference/rubik/#connecting","title":"\ud83d\udd0c Connecting","text":"<p>Use <code>Rubik::connect()</code> to establish a database connection.</p>"},{"location":"reference/rubik/#example-sqlite","title":"Example \u2014 SQLite","text":"<pre><code>Rubik::connect(\n    driver: Driver::SQLITE,\n    path: __DIR__ . '/database.sqlite'\n);\n</code></pre> <p>\ud83d\udca1 Automatically enables <code>PRAGMA foreign_keys = ON</code>.</p>"},{"location":"reference/rubik/#example-mysql","title":"Example \u2014 MySQL","text":"<pre><code>Rubik::connect(\n    driver: Driver::MYSQL,\n    host: 'localhost',\n    port: 3306,\n    database: 'rubik_db',\n    username: 'root',\n    password: 'secret'\n);\n</code></pre> <p>Uses secure defaults: <code>utf8mb4</code>, <code>PDO::ERRMODE_EXCEPTION</code>, and no emulated prepares.</p>"},{"location":"reference/rubik/#api-reference","title":"\ud83e\udde9 API Reference","text":""},{"location":"reference/rubik/#rubikconnect","title":"Rubik::connect()","text":"<pre><code>Rubik::connect(\n    Driver $driver,\n    string $username = '',\n    string $password = '',\n    string $database = '',\n    int $port = 3306,\n    string $host = 'localhost',\n    string $charset = 'utf8mb4',\n    string $path = ':memory:',\n    array $options = []\n): void\n</code></pre> <p>Connects to a database using the specified driver and configuration.</p> Parameter Type Description <code>driver</code> <code>Driver</code> The database driver (<code>Driver::SQLITE</code> or <code>Driver::MYSQL</code>). <code>username</code> <code>string</code> Database username (for MySQL). <code>password</code> <code>string</code> Database password (for MySQL). <code>database</code> <code>string</code> Database name (for MySQL). <code>port</code> <code>int</code> Port number (default: 3306). <code>host</code> <code>string</code> Host address (default: localhost). <code>charset</code> <code>string</code> Character set (default: utf8mb4). <code>path</code> <code>string</code> Path to SQLite database file (<code>:memory:</code> by default). <code>options</code> <code>array</code> Additional PDO options. <p>Throws <code>RuntimeException</code> if connection fails.</p>"},{"location":"reference/rubik/#rubikgetconn","title":"Rubik::getConn()","text":"<pre><code>public static function getConn(): PDO\n</code></pre> <p>Returns the active <code>PDO</code> connection. Throws a <code>RuntimeException</code> if not connected.</p> <pre><code>$pdo = Rubik::getConn();\n$pdo-&gt;exec(\"SELECT 1\");\n</code></pre>"},{"location":"reference/rubik/#rubikdisconnect","title":"Rubik::disconnect()","text":"<pre><code>public static function disconnect(): void\n</code></pre> <p>Closes the current database connection and resets the driver.</p> <pre><code>Rubik::disconnect();\n</code></pre>"},{"location":"reference/rubik/#rubikisconnected","title":"Rubik::isConnected()","text":"<pre><code>public static function isConnected(): bool\n</code></pre> <p>Checks whether a database connection is currently active.</p> <pre><code>if (Rubik::isConnected()) {\n    echo \"Connected!\";\n}\n</code></pre>"},{"location":"reference/rubik/#rubikgetdriver","title":"Rubik::getDriver()","text":"<pre><code>public static function getDriver(): Driver\n</code></pre> <p>Retrieves the active database driver.</p> <pre><code>if (Rubik::getDriver() === Driver::SQLITE) {\n    echo \"Running on SQLite\";\n}\n</code></pre>"},{"location":"reference/rubik/#rubiksetdriver","title":"Rubik::setDriver()","text":"<pre><code>public static function setDriver(Driver $driver): void\n</code></pre> <p>Forcefully sets the active driver manually.</p> <p>\u26a0\ufe0f Intended for internal use and testing only.</p> <p>Example:</p> <pre><code>Rubik::setDriver(Driver::MYSQL);\n</code></pre>"},{"location":"reference/rubik/#dsn-resolution","title":"\u2699\ufe0f DSN Resolution","text":"<p>Rubik automatically builds the DSN string for the PDO connection:</p> Driver Example DSN SQLite <code>sqlite:/path/to/database.sqlite</code> MySQL <code>mysql:host=localhost;port=3306;dbname=rubik_db;charset=utf8mb4</code> <p>You rarely need to call this directly \u2014 it\u2019s handled internally by <code>connect()</code>.</p>"},{"location":"reference/rubik/#default-pdo-options","title":"\ud83e\uddf0 Default PDO Options","text":"<p>Rubik sets sane and secure defaults:</p> Option Value <code>PDO::ATTR_ERRMODE</code> <code>PDO::ERRMODE_EXCEPTION</code> <code>PDO::ATTR_DEFAULT_FETCH_MODE</code> <code>PDO::FETCH_ASSOC</code> <code>PDO::ATTR_EMULATE_PREPARES</code> <code>false</code> <code>PDO::ATTR_STRINGIFY_FETCHES</code> <code>false</code>"},{"location":"reference/rubik/#example-complete-connection-setup","title":"\ud83e\uddfe Example \u2014 Complete Connection Setup","text":"<pre><code>use AdaiasMagdiel\\Rubik\\Rubik;\nuse AdaiasMagdiel\\Rubik\\Enum\\Driver;\n\ntry {\n    Rubik::connect(\n        driver: Driver::MYSQL,\n        host: '127.0.0.1',\n        database: 'rubik_orm',\n        username: 'root',\n        password: '123456'\n    );\n\n    echo \"Connected successfully via \" . Rubik::getDriver()-&gt;value;\n} catch (RuntimeException $e) {\n    echo \"Connection failed: \" . $e-&gt;getMessage();\n}\n</code></pre>"},{"location":"reference/rubik/#related","title":"\ud83d\udcd8 Related","text":"<ul> <li>Column \u2014 Defines table columns and constraints</li> <li>Model \u2014 Base class for ORM models</li> <li>Query \u2014 Fluent query builder</li> <li>SQL \u2014 Raw SQL expressions helper</li> </ul>"},{"location":"reference/sql/","title":"\ud83e\udde9 SQL Raw Expressions","text":"<p>The <code>SQL</code> value object allows you to embed literal SQL expressions directly in your schema or queries. It is the official and safe way to express driver-specific SQL functions without Rubik escaping or binding them.</p>"},{"location":"reference/sql/#overview","title":"\u2699\ufe0f Overview","text":"<p>Normally, Rubik ORM quotes and binds all values to prevent SQL injection. However, in some cases \u2014 such as <code>CURRENT_TIMESTAMP</code>, <code>NOW()</code>, <code>UUID()</code> or <code>gen_random_uuid()</code> \u2014 you need to embed a literal SQL expression verbatim.</p> <p>That\u2019s exactly what <code>SQL::raw()</code> is for.</p> <pre><code>use AdaiasMagdiel\\Rubik\\SQL;\n\n$expr = SQL::raw('CURRENT_TIMESTAMP');\n</code></pre> <p>When Rubik detects this type, it injects the expression as-is into the generated SQL, without adding quotes, parameters, or bindings.</p>"},{"location":"reference/sql/#when-to-use","title":"\ud83e\uddf1 When to Use","text":"<p>You can safely use <code>SQL::raw()</code> in:</p> Context Description Column defaults Define literal defaults such as timestamps or UUIDs Query conditions Use SQL functions inside <code>WHERE</code> or <code>UPDATE</code> clauses Updates/Inserts Set system-generated values like <code>NOW()</code> or <code>datetime(\"now\")</code> Schema builder Add raw defaults or computed values directly in field definitions"},{"location":"reference/sql/#example-column-default","title":"\ud83e\uddee Example \u2013 Column Default","text":"<pre><code>use AdaiasMagdiel\\Rubik\\Column;\nuse AdaiasMagdiel\\Rubik\\SQL;\n\nclass User extends Model\n{\n    protected static string $table = 'users';\n\n    protected static function fields(): array\n    {\n        return [\n            'id' =&gt; Column::Integer(primaryKey: true, autoincrement: true),\n            'name' =&gt; Column::Varchar(length: 100, notNull: true),\n            'email' =&gt; Column::Varchar(length: 150, notNull: true, unique: true),\n            'created_at' =&gt; Column::Datetime(default: SQL::raw('CURRENT_TIMESTAMP')),\n            'updated_at' =&gt; Column::Datetime(default: SQL::raw('CURRENT_TIMESTAMP')),\n        ];\n    }\n}\n</code></pre> <p>Generated SQL (SQLite):</p> <pre><code>CREATE TABLE users (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    name TEXT NOT NULL,\n    email TEXT NOT NULL UNIQUE,\n    created_at TEXT DEFAULT CURRENT_TIMESTAMP,\n    updated_at TEXT DEFAULT CURRENT_TIMESTAMP\n);\n</code></pre>"},{"location":"reference/sql/#example-in-queries","title":"\ud83d\udd0d Example \u2013 In Queries","text":"<p>You can include raw SQL inside queries seamlessly:</p> <pre><code>use AdaiasMagdiel\\Rubik\\SQL;\n\n$users = User::query()\n    -&gt;select([\n        'id',\n        'name',\n        SQL::raw('LENGTH(name) AS name_length'),\n    ])\n    -&gt;all();\n</code></pre> <p>SQL generated:</p> <pre><code>SELECT id, name, LENGTH(name) AS name_length FROM users;\n</code></pre>"},{"location":"reference/sql/#raw-conditions","title":"Raw Conditions","text":"<pre><code>User::query()\n    -&gt;where(SQL::raw('DATE(created_at)'), '&gt;=', SQL::raw('DATE(\"2025-01-01\")'))\n    -&gt;all();\n</code></pre> <p>SQL generated:</p> <pre><code>SELECT * FROM users WHERE DATE(created_at) &gt;= DATE(\"2025-01-01\");\n</code></pre> <p>\ud83d\udca1 Rubik automatically detects <code>SQL</code> instances and injects them unescaped.</p>"},{"location":"reference/sql/#example-updates-with-raw-sql","title":"\u270f\ufe0f Example \u2013 Updates with Raw SQL","text":"<pre><code>User::query()\n    -&gt;where('active', true)\n    -&gt;update(['updated_at' =&gt; SQL::raw('CURRENT_TIMESTAMP')]);\n</code></pre> <p>SQL generated:</p> <pre><code>UPDATE users SET updated_at = CURRENT_TIMESTAMP WHERE active = 1;\n</code></pre>"},{"location":"reference/sql/#example-inserts-with-raw-sql","title":"\ud83e\udde9 Example \u2013 Inserts with Raw SQL","text":"<pre><code>User::insert([\n    'name' =&gt; 'Anonymous',\n    'email' =&gt; 'anon@example.com',\n    'created_at' =&gt; SQL::raw('datetime(\"now\")'),\n]);\n</code></pre> <p>Rubik detects the raw SQL expression and includes it directly, without binding.</p>"},{"location":"reference/sql/#internals","title":"\u2699\ufe0f Internals","text":"<p>The <code>SQL</code> class is an immutable value object:</p> <pre><code>final class SQL\n{\n    private string $expr;\n\n    public function __construct(string $expr)\n    {\n        $this-&gt;expr = $expr;\n    }\n\n    public function __toString(): string\n    {\n        return $this-&gt;expr;\n    }\n\n    public static function raw(string $expr): static\n    {\n        return new static($expr);\n    }\n}\n</code></pre> <p>Internally, Rubik checks:</p> <pre><code>if ($value instanceof SQL) {\n    // Inject expression as-is\n}\n</code></pre> <p>This logic is used consistently in:</p> <ul> <li><code>Column</code> validators and defaults</li> <li><code>Query</code> builder (<code>update</code>, <code>where</code>, <code>select</code>)</li> <li><code>SchemaTrait</code> during table creation</li> </ul>"},{"location":"reference/sql/#example-full-model-with-raw-defaults","title":"\ud83e\uddf1 Example \u2013 Full Model with Raw Defaults","text":"<pre><code>use AdaiasMagdiel\\Rubik\\Column;\nuse AdaiasMagdiel\\Rubik\\Model;\nuse AdaiasMagdiel\\Rubik\\SQL;\n\nclass Product extends Model\n{\n    protected static string $table = 'products';\n\n    protected static function fields(): array\n    {\n        return [\n            'id' =&gt; Column::Integer(primaryKey: true, autoincrement: true),\n            'name' =&gt; Column::Varchar(length: 255, notNull: true),\n            'sku' =&gt; Column::Varchar(length: 50, unique: true),\n            'created_at' =&gt; Column::Datetime(default: SQL::raw('CURRENT_TIMESTAMP')),\n            'updated_at' =&gt; Column::Datetime(default: SQL::raw('CURRENT_TIMESTAMP')),\n        ];\n    }\n}\n</code></pre>"},{"location":"reference/sql/#summary","title":"\ud83e\uddfe Summary","text":"Context Example SQL Output Column default <code>Column::Datetime(default: SQL::raw('CURRENT_TIMESTAMP'))</code> <code>DEFAULT CURRENT_TIMESTAMP</code> Query select <code>SQL::raw('COUNT(*) AS total')</code> Adds computed columns WHERE clause <code>-&gt;where(SQL::raw('DATE(created_at)'), '&gt;=', SQL::raw('DATE(\"2025-01-01\")'))</code> Unquoted expressions Update <code>-&gt;update(['updated_at' =&gt; SQL::raw('CURRENT_TIMESTAMP')])</code> Literal update Insert <code>'created_at' =&gt; SQL::raw('datetime(\"now\")')</code> Raw expression"},{"location":"reference/sql/#security-notes","title":"\u26a0\ufe0f Security Notes","text":"<p><code>SQL::raw()</code> is powerful but must be used carefully.</p> <p>\u2705 Safe examples:</p> <ul> <li>System constants like <code>CURRENT_TIMESTAMP</code>, <code>NOW()</code></li> <li>Internal SQL functions: <code>LENGTH()</code>, <code>DATE()</code>, <code>UUID()</code></li> </ul> <p>\ud83d\udeab Unsafe examples:</p> <ul> <li>Concatenating user input into <code>SQL::raw()</code></li> <li>Using unvalidated external data</li> </ul> <p>\u26a0\ufe0f Never pass user input directly to <code>SQL::raw()</code>. It disables escaping, making your query vulnerable to SQL injection.</p>"},{"location":"reference/sql/#see-also","title":"\ud83e\udded See Also","text":"<ul> <li>Column Reference \u2014 define types and defaults with SQL expressions</li> <li>Queries \u2014 use raw SQL inside select and where clauses</li> </ul> <p>\ud83d\udca1 If you need full control over SQL fragments, <code>SQL::raw()</code> is your trusted escape hatch \u2014 minimal, explicit, and safe when used with care.</p>"},{"location":"reference/traits/","title":"\ud83e\udde9 Model Traits","text":"<p>Rubik ORM's <code>Model</code> class is modular and built on top of four core traits that separate responsibilities:</p> <ul> <li>SchemaTrait \u2192 defines the table structure and lifecycle (create, drop, truncate)</li> <li>CrudTrait \u2192 handles persistence (insert, update, delete)</li> <li>QueryTrait \u2192 provides query and relationship methods</li> <li>SerializationTrait \u2192 controls how models are serialized to arrays or JSON</li> </ul> <p>Each trait can be reused independently in custom base models.</p>"},{"location":"reference/traits/#schematrait","title":"\u2699\ufe0f <code>SchemaTrait</code>","text":"<p>Defines and manages the table schema of the model.</p>"},{"location":"reference/traits/#methods","title":"\ud83d\udd27 Methods","text":"Method Description <code>protected static function fields(): array</code> Must be implemented in the model to define columns. <code>public static function primaryKey(): string</code> Returns the primary key column. <code>public static function getTableName(): string</code> Resolves the table name (uses <code>$table</code> property or class name). <code>public static function createTable(bool $ifNotExists = false): bool</code> Creates the table based on <code>fields()</code>. <code>public static function dropTable(bool $ifExists = false): bool</code> Drops the table completely. <code>public static function truncateTable(): bool</code> Deletes all rows but keeps the structure. <code>protected static function getFieldString(array $field): string</code> Generates driver-specific SQL for a column. <code>protected static function escapeDefaultValue(mixed $value): string</code> Escapes default values and <code>SQL::raw()</code> expressions."},{"location":"reference/traits/#example","title":"\ud83e\uddf1 Example","text":"<pre><code>use AdaiasMagdiel\\Rubik\\Model;\nuse AdaiasMagdiel\\Rubik\\Column;\nuse AdaiasMagdiel\\Rubik\\SQL;\n\nclass User extends Model\n{\n    protected static string $table = 'users';\n\n    protected static function fields(): array\n    {\n        return [\n            'id' =&gt; Column::Integer(primaryKey: true, autoincrement: true),\n            'name' =&gt; Column::Varchar(length: 120, notNull: true),\n            'email' =&gt; Column::Varchar(length: 200, notNull: true, unique: true),\n            'created_at' =&gt; Column::Datetime(default: SQL::raw('CURRENT_TIMESTAMP')),\n        ];\n    }\n}\n</code></pre> <pre><code>User::createTable(ifNotExists: true);\n</code></pre>"},{"location":"reference/traits/#crudtrait","title":"\ud83d\udcbe <code>CrudTrait</code>","text":"<p>Implements basic Create, Read, Update, Delete persistence methods.</p>"},{"location":"reference/traits/#methods_1","title":"\ud83d\udd27 Methods","text":"Method Description <code>save(bool $ignore = false): bool</code> Inserts or updates the model automatically. <code>update(): bool</code> Updates only modified fields (<code>_dirty</code>). <code>delete(): bool</code> Deletes the current record from the table. <code>insertMany(array $records): bool</code> Bulk insert multiple rows in one transaction."},{"location":"reference/traits/#behavior","title":"\ud83e\udde0 Behavior","text":"<ul> <li>On <code>save()</code>, if the primary key is set, it tries to update; otherwise it inserts.</li> <li>Tracks dirty fields to avoid redundant updates.</li> <li>After insertion, retrieves the auto-incremented ID.</li> </ul>"},{"location":"reference/traits/#example_1","title":"\ud83e\udde9 Example","text":"<pre><code>$user = new User();\n$user-&gt;name = 'Alice';\n$user-&gt;email = 'alice@example.com';\n$user-&gt;save();\n\n$user-&gt;name = 'Alice B.';\n$user-&gt;save();\n\n$user-&gt;delete();\n</code></pre>"},{"location":"reference/traits/#querytrait","title":"\ud83d\udd0d <code>QueryTrait</code>","text":"<p>Provides the query builder interface and relationship handling.</p>"},{"location":"reference/traits/#methods_2","title":"\ud83d\udd27 Methods","text":"Method Description <code>static query(): Query</code> Returns a new <code>Query</code> builder for the model. <code>static find(mixed $id): ?self</code> Finds a record by primary key. <code>static first(): ?self</code> Retrieves the first record. <code>static all(): array</code> Retrieves all records as model instances. <code>static paginate(int $page, int $perPage): array</code> Returns paginated results."},{"location":"reference/traits/#relationships","title":"\ud83d\udd17 Relationships","text":"Method Type Description <code>belongsTo(string $related, string $foreignKey, string $ownerKey = 'id')</code> Defines inverse relation (foreign key on current model). <code>hasOne(string $related, string $foreignKey, string $localKey = 'id')</code> Defines one-to-one relation. <code>hasMany(string $related, string $foreignKey, string $localKey = 'id')</code> Defines one-to-many relation. <code>belongsToMany(string $related, string $pivotTable, string $foreignKey, string $relatedKey, string $localKey = 'id', string $relatedOwnerKey = 'id')</code> Defines many-to-many relation via a pivot table."},{"location":"reference/traits/#example_2","title":"\ud83e\udde9 Example","text":"<pre><code>class Post extends Model\n{\n    protected static string $table = 'posts';\n\n    protected static function fields(): array\n    {\n        return [\n            'id' =&gt; Column::Integer(primaryKey: true, autoincrement: true),\n            'user_id' =&gt; Column::Integer(\n                notNull: true,\n                foreignKey: Column::ForeignKey('id', 'users', onDelete: 'CASCADE')['foreign_key']\n            ),\n            'title' =&gt; Column::Varchar(length: 200, notNull: true),\n            'body' =&gt; Column::Text(),\n        ];\n    }\n\n    protected static function relationships(): array\n    {\n        return [\n            'user' =&gt; [\n                'type' =&gt; 'belongsTo',\n                'related' =&gt; User::class,\n                'foreignKey' =&gt; 'user_id',\n                'ownerKey' =&gt; 'id',\n            ],\n        ];\n    }\n}\n</code></pre> <pre><code>$post = Post::find(1);\necho $post-&gt;user-&gt;name;\n</code></pre> <p>Relationships are automatically resolved via <code>__get()</code> and cached in memory.</p>"},{"location":"reference/traits/#serializationtrait","title":"\ud83e\uddee <code>SerializationTrait</code>","text":"<p>Handles conversion to arrays and JSON.</p> <p>All models implement <code>JsonSerializable</code> and define <code>toArray()</code> and <code>jsonSerialize()</code>.</p>"},{"location":"reference/traits/#methods_3","title":"\ud83d\udd27 Methods","text":"Method Description <code>toArray(): array</code> Returns the model's internal data array. <code>jsonSerialize(): array</code> Defines how it is serialized into JSON."},{"location":"reference/traits/#example_3","title":"\ud83e\udde9 Example","text":"<pre><code>$user = User::find(1);\nprint_r($user-&gt;toArray());\necho json_encode($user);\n</code></pre> <p>Output:</p> <pre><code>{\n  \"id\": 1,\n  \"name\": \"Alice\",\n  \"email\": \"alice@example.com\",\n  \"created_at\": \"2025-10-16 12:34:56\"\n}\n</code></pre> <p>\ud83d\udca1 Maybe you want to reimplement the <code>toArray()</code> method to handle some custom specifics for your model \u2014 e.g., nested relationships or computed fields.</p>"},{"location":"reference/traits/#summary","title":"\ud83e\udded Summary","text":"Trait Responsibility Example Use <code>SchemaTrait</code> Defines table schema &amp; creates/drops tables <code>User::createTable()</code> <code>CrudTrait</code> Persists model data <code>$user-&gt;save()</code> <code>QueryTrait</code> Queries and relationships <code>User::query()-&gt;where('active', true)-&gt;all()</code> <code>SerializationTrait</code> Converts model to JSON or array <code>json_encode($user)</code> <p>\ud83d\udca1 Each trait is modular \u2014 you can extend or override them in your own base model to customize persistence, schema generation, or serialization behavior.</p>"}]}